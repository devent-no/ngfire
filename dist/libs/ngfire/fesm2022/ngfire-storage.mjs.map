{"version":3,"file":"ngfire-storage.mjs","sources":["../../../../libs/ngfire/storage/src/operators.ts","../../../../libs/ngfire/storage/src/tokens.ts","../../../../libs/ngfire/storage/src/service.ts","../../../../libs/ngfire/storage/src/ngfire-storage.ts"],"sourcesContent":["import {Observable} from 'rxjs';\nimport {debounceTime, map} from 'rxjs/operators';\nimport type { UploadTaskSnapshot, UploadTask } from 'firebase/storage';\n\nexport function fromTask(task: UploadTask): Observable<UploadTaskSnapshot> {\n  return new Observable<UploadTaskSnapshot>((subscriber) => {\n    const progress = (snap: UploadTaskSnapshot): void => subscriber.next(snap);\n    const error = (e: Error): void => subscriber.error(e);\n    const complete = (): void => subscriber.complete();\n    // emit the current state of the task\n    progress(task.snapshot);\n    // emit progression of the task\n    const unsubscribeFromOnStateChanged = task.on('state_changed', progress);\n    // use the promise form of task, to get the last success snapshot\n    task.then(\n        (snapshot) => {\n          progress(snapshot);\n          setTimeout(() => complete(), 0);\n        },\n        (e) => {\n          progress(task.snapshot);\n          setTimeout(() => error(e), 0);\n        },\n    );\n    // the unsubscribe method returns by storage isn't typed in the\n    // way rxjs expects, Function vs () => void, so wrap it\n    return function unsubscribe() {\n      unsubscribeFromOnStateChanged();\n    };\n  }).pipe(\n      // since we're emitting first the current snapshot and then progression\n      // it's possible that we could double fire synchronously; namely when in\n      // a terminal state (success, error, canceled). Debounce to address.\n      debounceTime(0),\n  );\n}\n\nexport interface PercentageSnapshot {\n  progress: number;\n  snapshot: UploadTaskSnapshot;\n}\nexport function percentage(task: UploadTask): Observable<PercentageSnapshot> {\n  return fromTask(task).pipe(\n    map((snapshot) => ({\n      progress: (snapshot.bytesTransferred / snapshot.totalBytes) * 100,\n      snapshot,\n    })),\n  );\n}","import { inject, InjectFlags, InjectionToken } from \"@angular/core\";\nimport { FirebaseStorage, getStorage } from \"firebase/storage\";\nimport { FIREBASE_APP } from \"ngfire/app\";\nimport { getConfig, STORAGE_BUCKET } from \"ngfire/tokens\";\n\n\nexport const FIRE_STORAGE = new InjectionToken<FirebaseStorage>('Firebase Storage', {\n  providedIn: 'root',\n  factory: () => {\n    const config = getConfig();\n    const app = inject(FIREBASE_APP);\n    const bucket = inject(STORAGE_BUCKET, InjectFlags.Optional);\n    if (config.storage) {\n      return config.storage(app, bucket ?? undefined);\n    } else {\n      return getStorage(app, bucket ?? undefined);\n    }\n  },\n});\n","import { inject, Injectable, Injector } from \"@angular/core\";\nimport { ref, uploadBytesResumable, UploadMetadata } from \"firebase/storage\";\nimport { FIRE_STORAGE } from \"./tokens\";\n\n@Injectable({ providedIn: 'root' })\nexport class FireStorage {\n  private injector = inject(Injector);\n  protected bucket?: string;\n\n  protected get storage() {\n    return this.injector.get(FIRE_STORAGE);\n  }\n\n  ref(url: string) {\n    return ref(this.storage, url);\n  }\n\n  upload(url: string, bytes: Blob | Uint8Array | ArrayBuffer, metadata?: UploadMetadata) {\n    const ref = this.ref(url);\n    return uploadBytesResumable(ref, bytes, metadata);\n  }\n}","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}