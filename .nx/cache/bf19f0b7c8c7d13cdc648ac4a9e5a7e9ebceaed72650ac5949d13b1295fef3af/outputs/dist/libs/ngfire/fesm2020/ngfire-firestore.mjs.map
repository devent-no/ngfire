{"version":3,"file":"ngfire-firestore.mjs","sources":["../../../../libs/ngfire/firestore/src/operators.ts","../../../../libs/ngfire/firestore/src/tokens.ts","../../../../libs/ngfire/firestore/src/query.ts","../../../../libs/ngfire/firestore/src/firestore.ts","../../../../libs/ngfire/firestore/src/utils.ts","../../../../libs/ngfire/firestore/src/document.ts","../../../../libs/ngfire/firestore/src/collection.ts","../../../../libs/ngfire/firestore/src/sub-collection.ts","../../../../libs/ngfire/firestore/src/ngfire-firestore.ts"],"sourcesContent":["import type { DocumentData, DocumentReference, DocumentSnapshot, Query, QuerySnapshot, SnapshotListenOptions } from \"firebase/firestore\";\nimport { onSnapshot } from 'firebase/firestore';\nimport { Observable } from \"rxjs\";\n\nconst DEFAULT_OPTIONS = { includeMetadataChanges: false };\nexport function fromRef<T=DocumentData>(ref: DocumentReference<T>, options?: SnapshotListenOptions): Observable<DocumentSnapshot<T>>;\nexport function fromRef<T=DocumentData>(ref: Query<T>, options?: SnapshotListenOptions): Observable<QuerySnapshot<T>>;\nexport function fromRef<T=DocumentData>(\n  ref: DocumentReference<T> | Query<T>,\n  options: SnapshotListenOptions\n): Observable<DocumentSnapshot<T>> | Observable<QuerySnapshot<T>>;\nexport function fromRef<T=DocumentData>(\n  ref: any,\n  options: SnapshotListenOptions = DEFAULT_OPTIONS\n): Observable<any> {\n  /* eslint-enable @typescript-eslint/no-explicit-any */\n  return new Observable(subscriber => {\n    const unsubscribe = onSnapshot<T>(ref, options, {\n      next: subscriber.next.bind(subscriber), \n      error: subscriber.error.bind(subscriber), \n      complete: subscriber.complete.bind(subscriber),\n    });\n    return { unsubscribe };\n  });\n}","import { inject, InjectFlags, InjectionToken } from \"@angular/core\";\nimport { Firestore } from 'firebase/firestore';\nimport { initializeFirestore } from \"firebase/firestore\";\nimport { FIRESTORE_SETTINGS, getConfig } from \"ngfire/tokens\";\nimport { FIREBASE_APP } from \"ngfire/app\";\n\n\nexport const FIRESTORE = new InjectionToken<Firestore>('Firestore instance', {\n  providedIn: 'root',\n  factory: () => {\n    const config = getConfig();\n    const settings = inject(FIRESTORE_SETTINGS, InjectFlags.Optional);\n    const app = inject(FIREBASE_APP);\n    if (config.firestore) {\n      return config.firestore(app, settings ?? {});\n    } else {\n      return initializeFirestore(app, settings ?? {});\n    }\n  },\n});\n","// Note: These types are internal to Firebase and may change. Consider alternative approaches.\ntype Target = any;\ntype OrderBy = any;\ntype FieldFilter = any;\ntype Value = any;\ntype ArrayValue = any;\ntype MapValue = any;\ntype Timestamp = any;\ntype LatLng = any;\nimport type { Query } from 'firebase/firestore';\nimport { exist } from 'ngfire/core';\n\n\n// Simplfied version of \n// https://github.com/firebase/firebase-js-sdk/blob/master/packages/firestore/src/core/query.ts#L442\nexport function stringifyQuery(query: Query) {\n  if ('_query' in query) {\n    const target = (query as any)['_query'] as Target & { limitType: string };\n    return `${stringifyTarget(target)}|lt:${target.limitType})`;\n  }\n  return '';\n}\n\nfunction stringifyTarget(target: Target): string {\n  if (!target.orderBy) (target as any).orderBy = [];\n  let str = target.path.canonicalString();\n  if (target.collectionGroup !== null) {\n    str += '|cg:' + target.collectionGroup;\n  }\n  if (target.filters.length > 0) {\n    const fields = target.filters\n    .map((f: any) => stringifyFilter(f as FieldFilter))\n    .join(', ');\n    str += `|f:[${fields}]`;\n  }\n  if (exist(target.limit)) {\n    str += '|l:' + target.limit;\n  }\n  if (target.orderBy.length > 0) {\n    const order = target.orderBy\n    .map((o: any) => stringifyOrderBy(o))\n    .join(', ');\n    str += `|ob:[${order}]`;\n  }\n  if (target.startAt) {\n    str += '|lb:';\n    str += target.startAt.inclusive ? 'b:' : 'a:';\n    str += target.startAt.position.map((p: any) => canonifyValue(p)).join(',');\n  }\n  if (target.endAt) {\n    str += '|ub:';\n    str += target.endAt.inclusive ? 'a:' : 'b:';\n    str += target.endAt.position.map((p: any) => canonifyValue(p)).join(',');\n  }\n  return str;\n}\n\n/** Returns a debug description for `filter`. */\nexport function stringifyFilter(filter: FieldFilter): string {\n  return `${filter.field.canonicalString()} ${filter.op} ${canonifyValue(filter.value)}`;\n}\n\nexport function stringifyOrderBy(orderBy: OrderBy): string {\n  return `${orderBy.field.canonicalString()} (${orderBy.dir})`;\n}\n\n/* eslint-disable */\nfunction canonifyValue(value: Value): string {\n  if ('nullValue' in value) {\n    return 'null';\n  } else if ('booleanValue' in value) {\n    return '' + value.booleanValue;\n  } else if ('integerValue' in value) {\n    return '' + value.integerValue;\n  } else if ('doubleValue' in value) {\n    return '' + value.doubleValue;\n  } else if ('timestampValue' in value) {\n    return canonifyTimestamp(value.timestampValue!);\n  } else if ('stringValue' in value) {\n    return value.stringValue!;\n  } else if ('bytesValue' in value) {\n    return canonifyByteString(value.bytesValue!);\n  } else if ('referenceValue' in value) {\n    return value.referenceValue!;\n  } else if ('geoPointValue' in value) {\n    return canonifyGeoPoint(value.geoPointValue!);\n  } else if ('arrayValue' in value) {\n    return canonifyArray(value.arrayValue!);\n  } else if ('mapValue' in value) {\n    return canonifyMap(value.mapValue!);\n  } else {\n    throw new Error('Invalid value type: ' + JSON.stringify(value));\n  }\n}\n/* eslint-enable */\n\n\nfunction canonifyByteString(byteString: string | Uint8Array): string {\n  if (typeof byteString === 'string') return byteString;\n  return byteString.toString();\n}\n\n\n\nfunction canonifyTimestamp(timestamp: Timestamp): string {\n  return `time(${timestamp.toString()})`;\n}\n\nfunction canonifyGeoPoint(geoPoint: LatLng): string {\n  return `geo(${geoPoint.latitude},${geoPoint.longitude})`;\n}\n\nfunction canonifyMap(mapValue: MapValue): string {\n  // Iteration order in JavaScript is not guaranteed. To ensure that we generate\n  // matching canonical IDs for identical maps, we need to sort the keys.\n  const sortedKeys = Object.keys(mapValue.fields || {}).sort();\n  // eslint-disable-next-line\n  const content = sortedKeys.map(key => `${key}:${canonifyValue(mapValue.fields![key])}`).join(',');\n  return `{${content}}`;\n}\n\nfunction canonifyArray(arrayValue: ArrayValue): string {\n  const values = arrayValue.values || [];\n  return `[${values.map(canonifyValue).join(',')}]`;\n}\n","import { inject, Injectable, InjectFlags, Injector, PLATFORM_ID } from \"@angular/core\";\nimport { makeStateKey, TransferState } from \"@angular/platform-browser\";\nimport { collection, doc, DocumentData, DocumentSnapshot, query, queryEqual, QuerySnapshot, runTransaction, writeBatch } from 'firebase/firestore';\nimport type { Transaction, CollectionReference, DocumentReference, Query, QueryConstraint } from 'firebase/firestore';\nimport { FIRESTORE } from \"./tokens\";\nimport { shareWithDelay, assertCollection, assertPath, isCollectionRef, isDocPath, isQuery } from \"ngfire/core\";\nimport { fromRef } from \"./operators\";\nimport { isPlatformBrowser, isPlatformServer } from \"@angular/common\";\nimport { Observable } from \"rxjs\";\nimport { stringifyQuery } from \"./query\";\n\ntype Reference<E> = CollectionReference<E> | DocumentReference<E>;\ntype Snapshot<E = DocumentData> = DocumentSnapshot<E> | QuerySnapshot<E>;\n\n@Injectable({ providedIn: 'root' })\nexport class FirestoreService {\n  private memoryRef: Record<string, Observable<Snapshot>> = {};\n  private injector = inject(Injector);\n  private plateformId = inject(PLATFORM_ID);\n  /** Transfer state between server and  */\n  private transferState = inject(TransferState, InjectFlags.Optional);\n  /** Cache based state for document */\n  private state: Map<string | Query, Snapshot<unknown>> = new Map();\n\n  get db() {\n    return this.injector.get(FIRESTORE);\n  }\n\n  /** @internal Should only be used by FireCollection services */\n  setState<E>(\n    ref: DocumentReference<E> | CollectionReference<E> | Query<E>,\n    snap: Snapshot<E>\n  ) {\n    if (isCollectionRef(ref)) {\n      (snap as QuerySnapshot<E>).forEach(doc => this.state.set(doc.ref.path, doc));\n      this.state.set(ref.path, snap);\n    } else if (isQuery(ref)) {\n      (snap as QuerySnapshot<E>).forEach(doc => this.state.set(doc.ref.path, doc));\n      const key = stringifyQuery(ref as any);\n      this.state.set(key, snap);\n    } else {\n      this.state.set(ref.path, snap);\n    }\n  }\n\n  getState<E>(ref: DocumentReference<E>, delay?: number): DocumentSnapshot<E>\n  getState<E>(ref: CollectionReference<E>, delay?: number): QuerySnapshot<E>\n  getState<E>(ref: Query<E>, delay?: number): QuerySnapshot<E>\n  getState<E>(ref: DocumentReference<E> | CollectionReference<E> | Query<E>): Snapshot<E> | undefined\n  getState<E>(ref: DocumentReference<E> | CollectionReference<E> | Query<E>): Snapshot<E> | undefined {\n    if (isQuery(ref)) {\n      const key = stringifyQuery(ref as any);\n      return this.state.get(key) as Snapshot<E>;\n    } else {\n      return this.state.get(ref.path) as Snapshot<E>;\n    }\n  }\n\n  /** @internal Should only be used by FireCollection services */\n  fromMemory<E>(ref: DocumentReference<E>, delay?: number): Observable<DocumentSnapshot<E>>\n  fromMemory<E>(ref: CollectionReference<E>, delay?: number): Observable<QuerySnapshot<E>>\n  fromMemory<E>(ref: Query<E>, delay?: number): Observable<QuerySnapshot<E>>\n  fromMemory<E>(ref: DocumentReference<E> | CollectionReference<E> | Query<E>, delay?: number): Observable<Snapshot<E>>\n  fromMemory<E>(\n    ref: DocumentReference<E> | CollectionReference<E> | Query<E>,\n    delay?: number\n  ): Observable<Snapshot<E>> {\n    const key = isQuery(ref) ? stringifyQuery(ref as any) : ref.path;\n    if (!this.memoryRef[key]) {\n      this.memoryRef[key] = fromRef(ref as any).pipe(shareWithDelay(delay));\n    }\n    return this.memoryRef[key] as Observable<Snapshot<E>>;\n  }\n\n  /**\n   * @internal Should only be used by FireCollection services\n   * Get the transfer state for a specific ref and put it in the memory state\n   * Remove the reference to transfer state after first call\n   */\n  getTransfer<E>(ref: DocumentReference<E>): E | undefined\n  getTransfer<E>(ref: CollectionReference<E> | Query<E>): E[] | undefined\n  getTransfer<E>(ref: DocumentReference<E> | CollectionReference<E> | Query<E>): E[] | E | undefined\n  getTransfer<E>(ref: DocumentReference<E> | CollectionReference<E> | Query<E>) {\n    if (!this.transferState || !isPlatformBrowser(this.plateformId)) return;\n    const key = isQuery(ref) ? stringifyQuery(ref as any) : ref.path;\n    const stateKey = makeStateKey<E>(key);\n    if (!this.transferState.hasKey(stateKey)) return;\n    const value = this.transferState.get(stateKey, undefined);\n    this.transferState.remove(stateKey);\n    return value;\n  }\n\n  /** @internal Should only be used by FireCollection services */\n  setTransfer<E>(ref: DocumentReference<E>, value?: E): void\n  setTransfer<E>(ref: DocumentReference<E>[] | CollectionReference<E> | Query<E>, value?: E[]): void\n  setTransfer<E>(ref: DocumentReference<E> | DocumentReference<E>[] | CollectionReference<E> | Query<E>, value?: E | E[]): void\n  setTransfer<E>(ref: DocumentReference<E> | DocumentReference<E>[] | CollectionReference<E> | Query<E>, value?: E | E[]) {\n    if (!value) return;\n    if (!this.transferState || !isPlatformServer(this.plateformId)) return;\n    if (Array.isArray(ref) && Array.isArray(value)) {\n      ref.forEach((reference, i) => this.setTransfer(reference, value[i]));\n    } else if (!Array.isArray(ref)) {\n      const key = isQuery(ref) ? stringifyQuery(ref as any) : ref.path;\n      this.transferState.set(makeStateKey<any>(key), value);\n    }\n  }\n\n\n  clearCache(paths: string | string[] | Query) {\n    if (!paths) return;\n    if (Array.isArray(paths)) {\n      for (const path of paths) {\n        delete this.memoryRef[path];\n        this.state.delete(path);\n      }\n    } else if (typeof paths === 'string') {\n      delete this.memoryRef[paths];\n      this.state.delete(paths);\n    } else {\n      const key = stringifyQuery(paths);\n      delete this.memoryRef[key];\n      this.state.delete(key);\n    }\n  }\n\n  /** Get the reference of the document, collection or query */\n  public getRef<E>(path: string): Reference<E>;\n  public getRef<E>(paths: string[]): DocumentReference<E>[];\n  public getRef<E>(path: string, constraints: QueryConstraint[]): Query<E>;\n  // overload used internally when looping over paths array\n  public getRef<E>(\n    paths: string | string[],\n    constraints?: QueryConstraint[],\n  ): undefined | Query<E> | Query<E>[] | Reference<E> | DocumentReference<E>[] {\n    if (!arguments.length || !paths) return undefined;\n\n    // Array of docs\n    if (Array.isArray(paths)) {\n      return paths.map((path) => this.getRef<E>(path) as DocumentReference<E>);\n    }\n\n    const hasContraints = Array.isArray(constraints);\n    if (hasContraints) {\n      assertPath(paths);\n      assertCollection(paths);\n      const ref = collection(this.db, paths) as CollectionReference<E>;\n      return query(ref, ...constraints);\n    } else {\n      assertPath(paths);\n      if (isDocPath(paths)) return doc(this.db, paths) as DocumentReference<E>;\n      return collection(this.db, paths) as CollectionReference<E>;\n    }\n  }\n\n  batch() {\n    return writeBatch(this.db);\n  }\n\n  runTransaction<T>(cb: (transaction: Transaction) => Promise<T>) {\n    return runTransaction<T>(this.db, (tx) => cb(tx));\n  }\n\n  createId() {\n    return doc(collection(this.db, '__')).id;\n  }\n\n}","import { Timestamp } from \"firebase/firestore\";\n\n/** Return the full path of the doc */\nexport function getDocPath(path: string, id: string) {\n  // If path is smaller than id, id is the full path from ref\n  return path.split('/').length < id.split('/').length ? id : `${path}/${id}`;\n}\n\n/** Recursively all Timestamp into Date */\nexport function toDate<D>(target: D): D {\n  if (typeof target !== 'object') return target;\n  for (const key in target) {\n    const value = target[key];\n    if (!value || typeof value !== 'object') continue;\n    if (value instanceof Timestamp) {\n      target[key] = value.toDate() as any;\n      continue;\n    }\n    toDate(value)\n  }\n  return target;\n}\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { inject, NgZone, PLATFORM_ID } from '@angular/core';\nimport { writeBatch, runTransaction, getDoc, Transaction, DocumentSnapshot, FieldValue, setDoc, updateDoc } from 'firebase/firestore';\nimport type { DocumentData, DocumentReference, QueryDocumentSnapshot, WriteBatch } from 'firebase/firestore';\nimport { fromRef } from './operators';\nimport type { WriteOptions, UpdateCallback, MetaDocument, Params, FireEntity, DeepKeys } from 'ngfire/core';\nimport { keepUnstableUntilFirst, pathWithParams } from 'ngfire/core';\nimport { Observable, from, firstValueFrom } from 'rxjs';\nimport { tap, startWith, switchMap } from 'rxjs/operators';\n\nimport { isPlatformServer } from '@angular/common';\nimport { FirestoreService } from './firestore';\nimport { toDate } from './utils';\n\n/////////////\n// SERVICE //\n/////////////\n\nexport abstract class FireDocument<E extends DocumentData> {\n  protected platformId = inject(PLATFORM_ID);\n  protected zone = inject(NgZone);\n  protected firestore = inject(FirestoreService);\n  protected abstract readonly path: string;\n  protected idKey: DeepKeys<E> = 'id' as any;\n  /** If true, will store the document id (IdKey) onto the document */\n  protected storeId = false;\n  /**\n   * Cache the snapshot into a global store\n   */\n  protected memorize = false;\n  /**\n   * Delay before unsubscribing to a query (used only with memorized is true)\n   * Use Infinty for application long subscription\n   */\n  protected delayToUnsubscribe = 0;\n\n  protected onCreate?(entity: E, options: WriteOptions): unknown;\n  protected onUpdate?(entity: FireEntity<E>, options: WriteOptions): unknown;\n  protected onDelete?(path: string, options: WriteOptions): unknown;\n\n\n  protected get db() {\n    return this.firestore.db;\n  }\n\n  protected useCache<T extends E>(ref: DocumentReference<T>): Observable<T | undefined> {   \n    if (isPlatformServer(this.platformId)) {\n      return this.zone.runOutsideAngular(() => fromRef(ref)).pipe(\n        switchMap(async snap => this.snapToData(snap)),\n        tap(value => this.firestore.setTransfer(ref, value)),\n        keepUnstableUntilFirst(this.zone),\n      );\n    }\n    if (!this.memorize) {\n      return this.zone.runOutsideAngular(() => fromRef(ref)).pipe(\n        switchMap(async snap => this.snapToData(snap)),\n        keepUnstableUntilFirst(this.zone)\n      );\n    }\n    const transfer = this.firestore.getTransfer(ref);\n    const initial = this.firestore.getState(ref);\n    const snap$ = this.zone.runOutsideAngular(() => this.firestore.fromMemory<T>(ref, this.delayToUnsubscribe)).pipe(\n      tap(snap => this.firestore.setState(ref, snap)),\n      keepUnstableUntilFirst(this.zone)\n    );\n    if (transfer) return snap$.pipe(switchMap(async snap => this.snapToData(snap)), startWith(transfer));\n    if (initial) return snap$.pipe(startWith(initial), switchMap(async snap => this.snapToData(snap)));\n    return snap$.pipe(switchMap(async snap => this.snapToData(snap)));\n  }\n\n  protected clearCache<T extends E>(ref: DocumentReference<T>) {\n    return this.firestore.clearCache(ref.path);\n  }\n\n  /** Function triggered when adding/updating data to firestore */\n  protected toFirestore<T extends E = E>(entity: FireEntity<T>, actionType: 'create' | 'update'): any | Promise<any> {\n    if (actionType === 'create') {\n      const _meta: MetaDocument = { createdAt: new Date(), modifiedAt: new Date() };\n      return { _meta, ...entity };\n    } else {\n      return { ...entity, '_meta.modifiedAt': new Date() };\n    }\n  }\n\n  /** Function triggered when getting data from firestore */\n  protected fromFirestore<T extends E = E>(snapshot: DocumentSnapshot<T> | QueryDocumentSnapshot<T>): Promise<T> | T | undefined {\n    if (snapshot.exists()) {\n      return { ...toDate(snapshot.data()), [this.idKey]: snapshot.id };\n    } else {\n      return undefined;\n    }\n  }\n\n  batch() {\n    return writeBatch(this.db);\n  }\n\n  runTransaction<T>(cb: (transaction: Transaction) => Promise<T>) {\n    return runTransaction<T>(this.db, (tx) => cb(tx));\n  }\n\n  createId(params?: Params) {\n    return this.getRef(params)?.id;\n  }\n\n\n  /** Get the content of the snapshot */\n  protected snapToData<T extends E = E>(snap: DocumentSnapshot<T>) {\n    return this.fromFirestore<T>(snap);\n  }\n\n  /** Get the content of reference(s) */\n  protected async getFromRef<T extends E = E>(ref: DocumentReference<T>): Promise<T | undefined> {\n    const snap = await getDoc(ref);\n    return this.snapToData(snap);\n  }\n\n  /** Observable the content of reference(s)  */\n  protected fromRef<T extends E = E>(ref: DocumentReference<T>): Observable<T | undefined> {\n    return this.useCache(ref);\n  }\n\n  ///////////////\n  // SNAPSHOTS //\n  ///////////////\n\n  /** Get the reference of the document, collection or query */\n  public getRef<T extends E>(parameters?: Params): DocumentReference<T> {\n    const path = parameters ? pathWithParams(this.path, parameters) : this.path;\n    const ref = this.firestore.getRef<T>(path) as DocumentReference<T>;\n    if (!ref) throw new Error(`Could not create a reference out of path \"${path}\"`);\n    return ref;\n  }\n\n  /** Clear cache and get the latest value into the cache */\n  public async reload<T extends E = E>(parameters?: Params): Promise<T | undefined> {\n    if (!this.memorize) return;\n    const ref = this.getRef(parameters);\n    this.clearCache(ref);\n    return this.load(parameters);\n  }\n\n  /** Get the last content from the app (if value has been cached, it won't do a server request) */\n  public async load<T extends E>(parameters?: Params): Promise<T | undefined> {\n    return firstValueFrom(this.valueChanges(parameters));\n  }\n\n  /** Return the current value of the document from Firestore */\n  public async getValue<T extends E = E>(parameters?: Params): Promise<T | undefined> {\n    const ref = this.getRef<T>(parameters);\n    return this.getFromRef<T>(ref);\n  }\n\n  /** Listen to the changes of values of the document from Firestore */\n  public valueChanges<T extends E = E>(parameters?: Params): Observable<T | undefined> {\n    const ref = this.getRef<T>(parameters);\n    return this.fromRef<T>(ref);\n  }\n\n\n  ///////////\n  // WRITE //\n  ///////////\n  /**\n   * Create or update the document\n   * @param document The document to upsert\n   * @param options options to write the document on firestore\n   */\n  async upsert<T extends E>(document: FireEntity<T>, options: WriteOptions = {}): Promise<string> {\n    const id: string | FieldValue | undefined = document[this.idKey];\n    if (typeof id !== 'string') return this.create(document, options);\n    const ref = this.getRef(options.params);\n    const snap = (options?.write instanceof Transaction)\n      ? await options.write?.get(ref)\n      : await getDoc(ref);\n    if (snap.exists()) return this.create(document, options);\n    await this.update(document, options);\n    return id;\n  }\n\n  /**\n   * Create the document at the specified path\n   * @param document The document to create\n   * @param options options to write the document on firestore\n   */\n  async create<T extends E>(document: FireEntity<T>, options: WriteOptions = {}): Promise<string> {\n    const baseId: string | FieldValue | undefined = document[this.idKey];\n    const id = typeof baseId === 'string' ? baseId : this.createId();\n    const data = await this.toFirestore(document, 'create');\n    if (this.storeId) data[this.idKey] = id;\n    const ref = this.getRef(options.params);\n    if (options.write) {\n      (options.write as WriteBatch).set(ref, data);\n    } else {\n      await setDoc(ref, data);\n    }\n    if (this.onCreate) {\n      await this.onCreate(data, { write: options.write, ctx: options.ctx });\n    }\n    return id;\n  }\n\n  /**\n   * Delete the document from firestore\n   * @param options options to write the document on firestore\n   */\n  async delete<T extends E>(options: WriteOptions = {}) {\n    const { write = this.batch(), ctx, params } = options;\n    const ref = this.getRef<T>(params);\n    write.delete(ref);\n    if (this.onDelete) {\n      await this.onDelete(ref.path, { write, ctx });\n    }\n    // If there is no atomic write provided\n    if (!options.write) {\n      await (write as WriteBatch).commit();\n      if (this.memorize) this.clearCache(ref);\n    }\n  }\n\n  /** Update document in Firestore */\n  update<T extends E>(document: FireEntity<T>, options?: WriteOptions): Promise<void>;\n  update<T extends E>(documentChanges: UpdateCallback<T>, options?: WriteOptions): Promise<void>;\n  async update<T extends E>(\n    changes: UpdateCallback<T> | FireEntity<T>,\n    options: WriteOptions = {}\n  ): Promise<void> {\n    const ref = this.getRef<T>(options.params);\n    if (typeof changes === 'function') {\n      await runTransaction(this.db, async (tx) => {\n        const snapshot = await tx.get(ref);\n        const doc = await this.fromFirestore<T>(snapshot);\n        if (doc && changes) {\n          const data = await changes(doc, tx);\n          const result = await this.toFirestore(data, 'update');\n          tx.update(ref, result);\n          if (this.onUpdate) {\n            await this.onUpdate(data, { write: tx, ctx: options.ctx });\n          }\n        }\n      });\n    } else {\n      const doc = await this.toFirestore<T>(changes, 'update');\n      if (options.write) {\n        (options.write as WriteBatch).update(ref, doc);\n      } else {\n        await updateDoc(ref, doc);\n      }\n      if (this.onUpdate) {\n        await this.onUpdate(doc, { write: options.write, ctx: options.ctx });\n      }\n    }\n    if (this.memorize) this.clearCache(ref);\n\n  }\n}\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { inject, NgZone, PLATFORM_ID } from '@angular/core';\nimport { writeBatch, runTransaction, doc, collection, Query, getDocs, getDoc, Transaction, DocumentSnapshot, FieldValue } from 'firebase/firestore';\nimport type { DocumentData, CollectionReference, DocumentReference, QueryConstraint, QueryDocumentSnapshot, QuerySnapshot, WriteBatch } from 'firebase/firestore';\nimport { fromRef } from './operators';\nimport type { WriteOptions, UpdateCallback, MetaDocument, Params, FireEntity, DeepKeys } from 'ngfire/core';\nimport { keepUnstableUntilFirst, isIdList, isNotUndefined, isPathRef, isQuery, pathWithParams } from 'ngfire/core';\nimport { Observable, of, combineLatest, from, firstValueFrom } from 'rxjs';\nimport { map, tap, startWith } from 'rxjs/operators';\n\nimport { isPlatformServer } from '@angular/common';\nimport { FirestoreService } from './firestore';\nimport { toDate, getDocPath } from './utils';\n\n/////////////\n// SERVICE //\n/////////////\n\nexport abstract class FireCollection<E extends DocumentData> {\n  protected platformId = inject(PLATFORM_ID);\n  protected zone = inject(NgZone);\n  protected firestore = inject(FirestoreService);\n  protected abstract readonly path: string;\n  protected idKey: DeepKeys<E> = 'id' as any;\n  /** If true, will store the document id (IdKey) onto the document */\n  protected storeId = false;\n  /**\n   * Cache the snapshot into a global store\n   */\n  protected memorize = false;\n  /**\n   * Delay before unsubscribing to a query (used only with memorized is true)\n   * Use Infinty for application long subscription\n   */\n  protected delayToUnsubscribe = 0;\n\n  protected onCreate?(entity: E, options: WriteOptions): unknown;\n  protected onUpdate?(entity: FireEntity<E>, options: WriteOptions): unknown;\n  protected onDelete?(id: string, options: WriteOptions): unknown;\n\n\n  protected get db() {\n    return this.firestore.db;\n  }\n\n  protected useCache<T extends E>(ref: DocumentReference<T>): Observable<T>\n  protected useCache<T extends E>(ref: Query<T>): Observable<T[]>\n  protected useCache<T extends E>(ref: DocumentReference<T> | Query<T>): Observable<T | T[]>   \n  protected useCache<T extends E>(ref: DocumentReference<T> | Query<T>): Observable<T | T[]> {\n    if (isPlatformServer(this.platformId)) {\n      return this.zone.runOutsideAngular(() => fromRef(ref as Query<T>)).pipe(\n        map(snap => this.snapToData(snap)),\n        tap(value => this.firestore.setTransfer(ref, value)),\n        keepUnstableUntilFirst(this.zone)\n      );\n    }\n    if (!this.memorize) {\n      return this.zone.runOutsideAngular(() => fromRef(ref as Query<T>)).pipe(\n        map(snap => this.snapToData(snap)),\n        keepUnstableUntilFirst(this.zone)\n      );\n    }\n    const transfer = this.firestore.getTransfer(ref);\n    const initial = this.firestore.getState(ref);\n    const snap$ = this.zone.runOutsideAngular(() => this.firestore.fromMemory(ref, this.delayToUnsubscribe)).pipe(\n      tap(snap => this.firestore.setState(ref, snap)),\n      keepUnstableUntilFirst(this.zone)\n    );\n    if (transfer) return snap$.pipe(map(snap => this.snapToData(snap)), startWith(transfer));\n    if (initial) return snap$.pipe(startWith(initial), map(snap => this.snapToData(snap)));\n    return snap$.pipe(map(snap => this.snapToData(snap)));\n  }\n\n  protected clearCache<T extends E>(refs: CollectionReference<T> | DocumentReference<T> | Query<T> | DocumentReference<T>[]) {\n    if (Array.isArray(refs)) return this.firestore.clearCache(refs.map(ref => ref.path));\n    if (isQuery(refs)) return this.firestore.clearCache(refs);\n    return this.firestore.clearCache(refs?.path);\n  }\n\n  /** Function triggered when adding/updating data to firestore */\n  protected toFirestore(entity: FireEntity<E>, actionType: 'add' | 'update'): any | Promise<any> {\n    if (actionType === 'add') {\n      const _meta: MetaDocument = { createdAt: new Date(), modifiedAt: new Date() };\n      return { _meta, ...entity };\n    } else {\n      return { ...entity, '_meta.modifiedAt': new Date() };\n    }\n  }\n\n  /** Function triggered when getting data from firestore */\n  protected fromFirestore(snapshot: DocumentSnapshot<E> | QueryDocumentSnapshot<E>): E | undefined {\n    if (snapshot.exists()) {\n      return { ...toDate(snapshot.data()), [this.idKey]: snapshot.id };\n    } else {\n      return undefined;\n    }\n  }\n\n  batch() {\n    return writeBatch(this.db);\n  }\n\n  runTransaction<T>(cb: (transaction: Transaction) => Promise<T>) {\n    return runTransaction<T>(this.db, (tx) => cb(tx));\n  }\n\n  createId() {\n    return doc(collection(this.db, '__')).id;\n  }\n\n\n  /** Get the content of the snapshot */\n  protected snapToData<T extends E = E>(snap: DocumentSnapshot<T>): T;\n  protected snapToData<T extends E = E>(snap: DocumentSnapshot<T>[]): T[];\n  protected snapToData<T extends E = E>(snap: QuerySnapshot<T>): T[];\n  protected snapToData<T extends E = E>(snap: QuerySnapshot<T> | DocumentSnapshot<T> | DocumentSnapshot<T>[]): T | T[];\n  protected snapToData<T extends E = E>(snap: QuerySnapshot<T> | DocumentSnapshot<T> | DocumentSnapshot<T>[]): T | T[] {\n    if (snap instanceof DocumentSnapshot) return this.fromFirestore(snap) as T;\n    const snaps = Array.isArray(snap) ? snap : snap.docs;\n    return snaps.map(s => this.snapToData(s)).filter(isNotUndefined);\n  }\n\n  /** Get the content of reference(s) */\n  protected async getFromRef<T extends E = E>(ref: DocumentReference<T>): Promise<T | undefined>;\n  protected async getFromRef<T extends E = E>(ref: DocumentReference<T>[]): Promise<T[]>;\n  protected async getFromRef<T extends E = E>(ref: CollectionReference<T> | Query<T>): Promise<T[]>;\n  protected async getFromRef<T extends E = E>(\n    ref: DocumentReference<T> | DocumentReference<T>[] | CollectionReference<T> | Query<T>\n  ): Promise<undefined | T | T[]>;\n  protected async getFromRef<T extends E = E>(\n    ref: DocumentReference<T> | DocumentReference<T>[] | CollectionReference<T> | Query<T>\n  ): Promise<undefined | T | T[]> {\n    if (Array.isArray(ref)) return Promise.all(ref.map(getDoc)).then(snaps => this.snapToData(snaps));\n    const snap = (ref.type === 'document') ? await getDoc(ref) : await getDocs(ref);\n    return this.snapToData(snap);\n  }\n\n  /** Observable the content of reference(s)  */\n  protected fromRef<T extends E = E>(ref: DocumentReference<T>): Observable<T | undefined>;\n  protected fromRef<T extends E = E>(ref: DocumentReference<T>[]): Observable<T[]>;\n  protected fromRef<T extends E = E>(ref: CollectionReference<T> | Query<T>): Observable<T[]>;\n  protected fromRef<T extends E = E>(\n    ref: DocumentReference<T> | DocumentReference<T>[] | CollectionReference<T> | Query<T>\n  ): Observable<undefined | T | T[]>;\n  protected fromRef<T extends E = E>(\n    ref: DocumentReference<T> | DocumentReference<T>[] | CollectionReference<T> | Query<T>\n  ): Observable<undefined | T | T[]> {\n    if (Array.isArray(ref)) {\n      if (!ref.length) return of([]);\n      const queries = ref.map(r => this.useCache(r));\n      return combineLatest(queries);\n    } else {\n      return this.useCache(ref);\n    }\n  }\n\n  ///////////////\n  // SNAPSHOTS //\n  ///////////////\n\n  /** Get the reference of the document, collection or query */\n  public getRef<T extends E = E>(): CollectionReference<T>;\n  public getRef<T extends E = E>(ids: string[], params?: Params): DocumentReference<T>[];\n  public getRef<T extends E = E>(constraints: QueryConstraint[], params: Params): Query<T>;\n  public getRef<T extends E = E>(id: string, params?: Params): DocumentReference<T>;\n  public getRef<T extends E = E>(path: string, params?: Params): DocumentReference<T> | CollectionReference<T>;\n  public getRef<T extends E = E>(params: Params): CollectionReference<T>;\n  public getRef<T extends E = E>(\n    ids?: string | string[] | Params | QueryConstraint[],\n    params?: Params\n  ): undefined | Query<T> | CollectionReference<T> | DocumentReference<T> | DocumentReference<T>[]\n  public getRef<T extends E>(\n    ids?: string | string[] | Params | QueryConstraint[],\n    parameters?: Params\n  ): undefined | Query<T> | CollectionReference<T> | DocumentReference<T> | DocumentReference<T>[] {\n    // Collection\n    if (!arguments.length) return this.firestore.getRef(this.path);\n    // Id is undefined or null\n    if (!ids) return undefined;\n    \n    if (Array.isArray(ids)) {\n      // List of ref\n      if ((ids as any[]).every(isPathRef)) return this.firestore.getRef(ids as string[]);\n      \n      const path = pathWithParams(this.path, parameters);\n      // List of ids\n      if (isIdList(ids)) return this.firestore.getRef(ids.map((id) => getDocPath(path, id)));\n      // List of constraints\n      return this.firestore.getRef(path, ids);\n    }\n\n    if (typeof ids === 'string') {\n      // Ref\n      if (isPathRef(ids)) return this.firestore.getRef(ids);\n      // Id\n      const path = pathWithParams(this.path, parameters);\n      return this.firestore.getRef(getDocPath(path, ids));\n    }\n\n    // Subcollection\n    return this.firestore.getRef(pathWithParams(this.path, ids));\n  }\n\n\n  /** Clear cache and get the latest value into the cache */\n  public async reload<T extends E = E>(ids?: string[]): Promise<T[]>;\n  public async reload<T extends E = E>(query?: QueryConstraint[]): Promise<T[]>;\n  public async reload<T extends E = E>(id?: string | null): Promise<T | undefined>;\n  public async reload<T extends E = E>(\n    idOrQuery?: string | string[] | QueryConstraint[] | null,\n  ): Promise<T | T[] | undefined>\n  public async reload<T extends E = E>(): Promise<T | T[] | undefined> {\n    if (!this.memorize) return;\n    const ref = this.getRef(...arguments);\n    if (!ref) return;\n    this.clearCache(ref);\n    return this.load(...arguments);\n  }\n\n  /** Get the last content from the app (if value has been cached, it won't do a server request) */\n  public async load<T extends E = E>(ids?: string[]): Promise<T[]>;\n  public async load<T extends E = E>(query?: QueryConstraint[]): Promise<T[]>;\n  public async load<T extends E = E>(id?: string | null): Promise<T | undefined>;\n  public async load<T extends E = E>(\n    idOrQuery?: string | string[] | QueryConstraint[] | null,\n  ): Promise<T | T[] | undefined>\n  public async load<T extends E>(): Promise<T | T[] | undefined> {\n    return firstValueFrom(this.valueChanges(...arguments));\n  }\n\n  /** Return the current value of the path from Firestore */\n  public async getValue<T extends E = E>(ids?: string[]): Promise<T[]>;\n  public async getValue<T extends E = E>(query?: QueryConstraint[]): Promise<T[]>;\n  public async getValue<T extends E = E>(id?: string | null): Promise<T | undefined>;\n  public async getValue<T extends E = E>(idOrQuery?: null | string | string[] | QueryConstraint[]): Promise<T | T[] | undefined>\n  public async getValue<T extends E = E>(): Promise<T | T[] | undefined> {\n    const ref = this.getRef<T>(...arguments);\n    if (!ref) return;\n    return this.getFromRef<T>(ref);\n  }\n\n  /** Listen to the changes of values of the path from Firestore */\n  public valueChanges<T extends E = E>(ids?: string[]): Observable<T[]>;\n  public valueChanges<T extends E = E>(query?: QueryConstraint[]): Observable<T[]>;\n  public valueChanges<T extends E = E>(id?: string | null): Observable<T | undefined>;\n  public valueChanges<T extends E = E>(\n    idOrQuery?: string | string[] | QueryConstraint[] | null,\n  ): Observable<T | T[] | undefined>;\n  public valueChanges<T extends E = E>(\n    idOrQuery?: string | string[] | QueryConstraint[] | null,\n  ): Observable<T | T[] | undefined> {\n    if (Array.isArray(idOrQuery) && !idOrQuery.length) return of([]);\n    const ref = this.getRef<T>(...arguments);\n    if (!ref) return of(undefined);\n    return this.fromRef<T>(ref);\n  }\n\n\n  ///////////\n  // WRITE //\n  ///////////\n  /**\n   * Create or update documents\n   * @param documents One or many documents\n   * @param options options to write the document on firestore\n   */\n  upsert<T extends E>(documents: FireEntity<T>, options?: WriteOptions): Promise<string>;\n  upsert<T extends E>(documents: FireEntity<T>[], options?: WriteOptions): Promise<string[]>;\n  async upsert<T extends E>(\n    documents: FireEntity<T> | FireEntity<T>[],\n    options: WriteOptions = {}\n  ): Promise<string | string[]> {\n    const doesExist = async (doc: FireEntity<T>) => {\n      const id: string | FieldValue | undefined = doc[this.idKey];\n      if (typeof id !== 'string') return false;\n      const ref = this.getRef(id, options.params);\n      const snap = (options.write instanceof Transaction)\n        ? await options.write?.get(ref)\n        : await getDoc(ref);\n      return snap.exists();\n    };\n    const upsert = async (doc: FireEntity<T>) => {\n      const exists = await doesExist(doc);\n      if (!exists) return this.add(doc, options);\n      await this.update(doc, options);\n      return doc[this.idKey] as string;\n    }\n    return Array.isArray(documents)\n      ? Promise.all(documents.map(upsert))\n      : upsert(documents);\n  }\n\n  /**\n   * Add a document or a list of document to Firestore\n   * @param docs A document or a list of document\n   * @param options options to write the document on firestore\n   */\n  add<T extends E>(documents: FireEntity<T>, options?: WriteOptions): Promise<string>;\n  add<T extends E>(documents: FireEntity<T>[], options?: WriteOptions): Promise<string[]>;\n  async add<T extends E>(\n    documents: FireEntity<T> | FireEntity<T>[],\n    options: WriteOptions = {}\n  ): Promise<string | string[]> {\n    const docs = Array.isArray(documents) ? documents : [documents];\n    const { write = this.batch(), ctx } = options;\n    const operations = docs.map(async (value) => {\n      const id = (value[this.idKey] as string | undefined) || this.createId();\n      const data = await this.toFirestore(value, 'add');\n      if (this.storeId) data[this.idKey] = id;\n      const ref = this.getRef(id, options.params);\n      (write as WriteBatch).set(ref, data);\n      if (this.onCreate) {\n        await this.onCreate(data, { write, ctx });\n      }\n      return id;\n    });\n    const ids: string[] = await Promise.all(operations);\n    // If there is no atomic write provided\n    if (!options.write) {\n      await (write as WriteBatch).commit();\n    }\n    return Array.isArray(documents) ? ids : ids[0];\n  }\n\n  /**\n   * Remove one or several document from Firestore\n   * @param id A unique or list of id representing the document\n   * @param options options to write the document on firestore\n   */\n  async remove<T extends E>(id: string | string[], options: WriteOptions = {}) {\n    const { write = this.batch(), ctx } = options;\n    const ids: string[] = Array.isArray(id) ? id : [id];\n    const refs: DocumentReference<T>[] = [];\n    const operations = ids.map(async (docId) => {\n      const ref = this.getRef<T>(docId, options.params);\n      write.delete(ref);\n      if (this.onDelete) {\n        await this.onDelete(docId, { write, ctx });\n      }\n      refs.push(ref);\n    });\n    await Promise.all(operations);\n    // If there is no atomic write provided\n    if (!options.write) {\n      await (write as WriteBatch).commit();\n      if (this.memorize) this.clearCache(refs);\n    }\n  }\n\n  /** Remove all document of the collection */\n  async removeAll(options: WriteOptions = {}) {\n    const ref = options.params ? this.getRef(options.params) : this.getRef();\n    const snapshot = await getDocs(ref);\n    const ids = snapshot.docs.map((doc) => doc.id);\n    await this.remove(ids, options);\n    if (this.memorize) this.clearCache(ref);\n  }\n\n  /**\n   * Update one or several document in Firestore\n   */\n  update<T extends E>(entity: FireEntity<T> | FireEntity<T>[], options?: WriteOptions): Promise<void>;\n  update<T extends E>(id: string | string[], entityChanges: FireEntity<T>, options?: WriteOptions): Promise<void>;\n  update<T extends E>(\n    ids: string | string[],\n    stateFunction: UpdateCallback<T>,\n    options?: WriteOptions\n  ): Promise<Transaction[]>;\n  async update<T extends E>(\n    idsOrEntity: FireEntity<T> | FireEntity<T>[] | string | string[],\n    stateFnOrWrite?: UpdateCallback<T> | FireEntity<T> | WriteOptions,\n    options: WriteOptions = {}\n  ): Promise<void | Transaction[]> {\n    let ids: string[] = [];\n    let stateFunction: UpdateCallback<T> | undefined;\n    let getData: (docId: string) => FireEntity<T>;\n\n    const isEntity = (value: DocumentData | string): value is FireEntity<T> => {\n      return typeof value === 'object' && value[this.idKey];\n    };\n    const isEntityArray = (values: DocumentData | string[] | string): values is FireEntity<T>[] => {\n      return Array.isArray(values) && values.every((value) => isEntity(value));\n    };\n\n    if (isEntity(idsOrEntity)) {\n      ids = [idsOrEntity[this.idKey] as string];\n      getData = () => idsOrEntity;\n      options = (stateFnOrWrite as WriteOptions) || {};\n    } else if (isEntityArray(idsOrEntity)) {\n      const entityMap = new Map(\n        idsOrEntity.map((entity) => [entity[this.idKey] as string, entity])\n      );\n      ids = Array.from(entityMap.keys());\n      getData = (docId) => entityMap.get(docId)!;\n      options = (stateFnOrWrite as WriteOptions) || {};\n    } else if (typeof stateFnOrWrite === 'function') {\n      ids = Array.isArray(idsOrEntity) ? idsOrEntity : [idsOrEntity];\n      stateFunction = stateFnOrWrite as UpdateCallback<T>;\n    } else if (typeof stateFnOrWrite === 'object') {\n      ids = Array.isArray(idsOrEntity) ? idsOrEntity : [idsOrEntity];\n      getData = () => stateFnOrWrite as FireEntity<T>;\n    } else {\n      throw new Error('Passed parameters match none of the function signatures.');\n    }\n\n    const { ctx } = options;\n    if (!Array.isArray(ids) || !ids.length) {\n      return;\n    }\n\n    // If update depends on the entity, use transaction\n    if (stateFunction) {\n      let refs: DocumentReference<T>[] = [];\n      await runTransaction(this.db, async (tx) => {\n        refs = [];\n        const operations = ids.map(async (id) => {\n          const ref = this.getRef<T>(id, options.params);\n          refs.push(ref);\n          const snapshot = await tx.get(ref);\n          const doc = this.fromFirestore(snapshot);\n          if (doc && stateFunction) {\n            const data = await stateFunction(doc as T, tx);\n            const result = await this.toFirestore(data, 'update');\n            tx.update(ref, result);\n            if (this.onUpdate) {\n              await this.onUpdate(data, { write: tx, ctx });\n            }\n          }\n          return tx;\n        });\n        return Promise.all(operations);\n      });\n      if (this.memorize) this.clearCache(refs);\n    } else {\n      const { write = this.batch() } = options;\n      const refs: DocumentReference<T>[] = [];\n      const operations = ids.map(async (docId) => {\n        const doc = getData(docId);\n        if (!docId) {\n          throw new Error(`Document should have an unique id to be updated, but none was found in ${doc}`);\n        }\n        const ref = this.getRef<T>(docId, options.params);\n        refs.push(ref);\n        const data = await this.toFirestore(doc, 'update');\n        (write as WriteBatch).update(ref, data);\n        if (this.onUpdate) {\n          await this.onUpdate(doc, { write, ctx });\n        }\n      });\n      await Promise.all(operations);\n      // If there is no atomic write provided\n      if (!options.write) {\n        await (write as WriteBatch).commit();\n        if (this.memorize) this.clearCache(refs)\n      }\n    }\n  }\n}\n","import { isPlatformServer } from \"@angular/common\";\nimport { collectionGroup, query } from \"firebase/firestore\";\nimport type { QueryDocumentSnapshot, DocumentSnapshot, Query, QueryConstraint, DocumentData } from 'firebase/firestore';\nimport { keepUnstableUntilFirst, isIdList, Params } from 'ngfire/core';\nimport { FireCollection } from \"./collection\";\nimport { toDate } from \"./utils\";\nimport { firstValueFrom, from, Observable, of } from \"rxjs\";\n\n\nexport abstract class FireSubCollection<E extends DocumentData> extends FireCollection<E> {\n  abstract path: string;\n  protected pathKey = 'path';\n  \n  get groupId() {\n    return this.path.split('/').pop() as string;\n  }\n\n  /** Function triggered when getting data from firestore */\n  protected fromFirestore(snapshot: DocumentSnapshot<E> | QueryDocumentSnapshot<E>): E | undefined {\n    if (snapshot.exists()) {\n      return {\n        ...toDate(snapshot.data()),\n        [this.idKey]: snapshot.id,\n        [this.pathKey]: snapshot.ref.path\n      };\n    } else {\n      return undefined;\n    }\n  }\n\n  public getGroupRef<T extends E = E>(constraints?: QueryConstraint[]): Query<T> | undefined {\n    const group = collectionGroup(this.db, this.groupId) as Query<T>;\n    if (!arguments.length) return group;\n    if (!constraints) return;\n    return query(group, ...constraints);\n  }\n\n  /** Observable the content of group reference(s)  */\n  protected fromGroupRef<T extends E = E>(ref: Query<T>): Observable<T[]> {\n    if (isPlatformServer(this.platformId)) {\n      return this.zone.runOutsideAngular(() => from(this.getFromRef(ref))).pipe(\n        keepUnstableUntilFirst(this.zone),\n      );\n    }\n    return this.useCache(ref);\n  }\n\n\n  /** Return the current value of the path from Firestore */\n  public async getValue<T extends E = E>(ids?: string[], params?: Params): Promise<T[]>;\n  public async getValue<T extends E = E>(params: Params): Promise<T[]>;\n  public async getValue<T extends E = E>(query?: QueryConstraint[], params?: Params): Promise<T[]>;\n  public async getValue<T extends E = E>(id?: string | null, params?: Params): Promise<T | undefined>;\n  public async getValue<T extends E = E>(\n    idOrQuery?: null | string | string[] | QueryConstraint[] | Params,\n    params?: Params\n  ): Promise<T | T[] | undefined> {\n    // If array is empty\n    if (Array.isArray(idOrQuery) && !idOrQuery.length) return [];\n\n    // Group query\n    const isEmpty = arguments.length === 0;\n    const isGroupQuery = arguments.length === 1 && Array.isArray(idOrQuery) && !isIdList(idOrQuery);\n\n    // Collection Query\n    const ref = (isEmpty || isGroupQuery)\n      ? this.getGroupRef<T>(...arguments)\n      : this.getRef<T>(...arguments);\n    if (!ref) return;\n    return this.getFromRef(ref);\n  }\n\n  /** Clear cache and get the latest value into the cache */\n  public async reload<T extends E = E>(ids?: string[], params?: Params): Promise<T[]>;\n  public async reload<T extends E = E>(params: Params): Promise<T[]>;\n  public async reload<T extends E = E>(query?: QueryConstraint[], params?: Params): Promise<T[]>;\n  public async reload<T extends E = E>(id?: string | null, params?: Params): Promise<T | undefined>;\n  public async reload<T extends E = E>(\n    idOrQuery?: null | string | string[] | QueryConstraint[] | Params,\n    params?: Params\n  ): Promise<T | T[] | undefined> {\n    const isEmpty = arguments.length === 0;\n    const isGroupQuery = arguments.length === 1 && Array.isArray(idOrQuery) && !isIdList(idOrQuery);\n    const ref = (isEmpty || isGroupQuery)\n      ? this.getGroupRef(...arguments)\n      : this.getRef(...arguments);\n    if (!ref) return;\n    if (this.memorize) {\n      Array.isArray(ref)\n        ? ref.forEach(r => this.clearCache(r))\n        : this.clearCache(ref);\n    }\n    return this.load(...arguments);\n  }\n  \n\n  /** Get the last content from the app (if value has been cached, it won't do a server request)  */\n  public load<T extends E = E>(ids?: string[], params?: Params): Promise<T[]>;\n  public load<T extends E = E>(params: Params): Promise<T[]>;\n  public load<T extends E = E>(query?: QueryConstraint[], params?: Params): Promise<T[]>;\n  public load<T extends E = E>(id?: string, params?: Params): Promise<T | undefined>;\n  public load<T extends E = E>(\n    idOrQuery?: string | string[] | QueryConstraint[] | Params,\n    params?: Params\n  ): Promise<T | T[] | undefined>;\n  public load<T extends E = E>(): Promise<T | T[] | undefined> {\n    return firstValueFrom(this.valueChanges(...arguments));\n  }\n\n  /** Return the current value of the path from Firestore */\n  public valueChanges<T extends E = E>(ids?: string[], params?: Params): Observable<T[]>;\n  public valueChanges<T extends E = E>(params: Params): Observable<T[]>;\n  public valueChanges<T extends E = E>(query?: QueryConstraint[], params?: Params): Observable<T[]>;\n  public valueChanges<T extends E = E>(id?: string, params?: Params): Observable<T | undefined>;\n  public valueChanges<T extends E = E>(\n    idOrQuery?: string | string[] | QueryConstraint[] | Params,\n    params?: Params\n  ): Observable<T | T[] | undefined>;\n  public valueChanges<T extends E = E>(\n    idOrQuery?: string | string[] | QueryConstraint[] | Params,\n    params?: Params\n  ): Observable<T | T[] | undefined> {\n    // If array is empty\n    if (Array.isArray(idOrQuery) && !idOrQuery.length) return of([]);\n    \n    // Check if group query\n    const isEmpty = arguments.length === 0;\n    const isGroupQuery = arguments.length === 1 && Array.isArray(idOrQuery) && !isIdList(idOrQuery);\n\n    // Group or Collection Query\n    const ref = (isEmpty || isGroupQuery)\n      ? this.getGroupRef<T>(...arguments)\n      : this.getRef<T>(...arguments);\n\n    if (!ref) return of(undefined);\n    return this.fromRef(ref);\n  }\n\n}","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":";;;;;;;;;;;AAIA,MAAM,eAAe,GAAG,EAAE,sBAAsB,EAAE,KAAK,EAAE,CAAC;SAO1C,OAAO,CACrB,GAAQ,EACR,UAAiC,eAAe,EAAA;;AAGhD,IAAA,OAAO,IAAI,UAAU,CAAC,UAAU,IAAG;AACjC,QAAA,MAAM,WAAW,GAAG,UAAU,CAAI,GAAG,EAAE,OAAO,EAAE;YAC9C,IAAI,EAAE,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC;YACtC,KAAK,EAAE,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC;YACxC,QAAQ,EAAE,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC;AAC/C,SAAA,CAAC,CAAC;QACH,OAAO,EAAE,WAAW,EAAE,CAAC;AACzB,KAAC,CAAC,CAAC;AACL;;MCjBa,SAAS,GAAG,IAAI,cAAc,CAAY,oBAAoB,EAAE;AAC3E,IAAA,UAAU,EAAE,MAAM;IAClB,OAAO,EAAE,MAAK;AACZ,QAAA,MAAM,MAAM,GAAG,SAAS,EAAE,CAAC;QAC3B,MAAM,QAAQ,GAAG,MAAM,CAAC,kBAAkB,EAAE,WAAW,CAAC,QAAQ,CAAC,CAAC;AAClE,QAAA,MAAM,GAAG,GAAG,MAAM,CAAC,YAAY,CAAC,CAAC;QACjC,IAAI,MAAM,CAAC,SAAS,EAAE;YACpB,OAAO,MAAM,CAAC,SAAS,CAAC,GAAG,EAAE,QAAQ,IAAI,EAAE,CAAC,CAAC;AAC9C,SAAA;AAAM,aAAA;YACL,OAAO,mBAAmB,CAAC,GAAG,EAAE,QAAQ,IAAI,EAAE,CAAC,CAAC;AACjD,SAAA;KACF;AACF,CAAA;;ACND;AACA;AACM,SAAU,cAAc,CAAC,KAAY,EAAA;IACzC,IAAI,QAAQ,IAAI,KAAK,EAAE;AACrB,QAAA,MAAM,MAAM,GAAI,KAAa,CAAC,QAAQ,CAAmC,CAAC;QAC1E,OAAO,CAAA,EAAG,eAAe,CAAC,MAAM,CAAC,OAAO,MAAM,CAAC,SAAS,CAAA,CAAA,CAAG,CAAC;AAC7D,KAAA;AACD,IAAA,OAAO,EAAE,CAAC;AACZ,CAAC;AAED,SAAS,eAAe,CAAC,MAAc,EAAA;IACrC,IAAI,CAAC,MAAM,CAAC,OAAO;AAAG,QAAA,MAAc,CAAC,OAAO,GAAG,EAAE,CAAC;IAClD,IAAI,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC;AACxC,IAAA,IAAI,MAAM,CAAC,eAAe,KAAK,IAAI,EAAE;AACnC,QAAA,GAAG,IAAI,MAAM,GAAG,MAAM,CAAC,eAAe,CAAC;AACxC,KAAA;AACD,IAAA,IAAI,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;AAC7B,QAAA,MAAM,MAAM,GAAG,MAAM,CAAC,OAAO;aAC5B,GAAG,CAAC,CAAC,CAAM,KAAK,eAAe,CAAC,CAAgB,CAAC,CAAC;aAClD,IAAI,CAAC,IAAI,CAAC,CAAC;AACZ,QAAA,GAAG,IAAI,CAAA,IAAA,EAAO,MAAM,CAAA,CAAA,CAAG,CAAC;AACzB,KAAA;AACD,IAAA,IAAI,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE;AACvB,QAAA,GAAG,IAAI,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC;AAC7B,KAAA;AACD,IAAA,IAAI,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;AAC7B,QAAA,MAAM,KAAK,GAAG,MAAM,CAAC,OAAO;aAC3B,GAAG,CAAC,CAAC,CAAM,KAAK,gBAAgB,CAAC,CAAC,CAAC,CAAC;aACpC,IAAI,CAAC,IAAI,CAAC,CAAC;AACZ,QAAA,GAAG,IAAI,CAAA,KAAA,EAAQ,KAAK,CAAA,CAAA,CAAG,CAAC;AACzB,KAAA;IACD,IAAI,MAAM,CAAC,OAAO,EAAE;QAClB,GAAG,IAAI,MAAM,CAAC;AACd,QAAA,GAAG,IAAI,MAAM,CAAC,OAAO,CAAC,SAAS,GAAG,IAAI,GAAG,IAAI,CAAC;QAC9C,GAAG,IAAI,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAM,KAAK,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAC5E,KAAA;IACD,IAAI,MAAM,CAAC,KAAK,EAAE;QAChB,GAAG,IAAI,MAAM,CAAC;AACd,QAAA,GAAG,IAAI,MAAM,CAAC,KAAK,CAAC,SAAS,GAAG,IAAI,GAAG,IAAI,CAAC;QAC5C,GAAG,IAAI,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAM,KAAK,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAC1E,KAAA;AACD,IAAA,OAAO,GAAG,CAAC;AACb,CAAC;AAED;AACM,SAAU,eAAe,CAAC,MAAmB,EAAA;AACjD,IAAA,OAAO,GAAG,MAAM,CAAC,KAAK,CAAC,eAAe,EAAE,CAAI,CAAA,EAAA,MAAM,CAAC,EAAE,CAAA,CAAA,EAAI,aAAa,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC;AACzF,CAAC;AAEK,SAAU,gBAAgB,CAAC,OAAgB,EAAA;AAC/C,IAAA,OAAO,CAAG,EAAA,OAAO,CAAC,KAAK,CAAC,eAAe,EAAE,CAAA,EAAA,EAAK,OAAO,CAAC,GAAG,CAAA,CAAA,CAAG,CAAC;AAC/D,CAAC;AAED;AACA,SAAS,aAAa,CAAC,KAAY,EAAA;IACjC,IAAI,WAAW,IAAI,KAAK,EAAE;AACxB,QAAA,OAAO,MAAM,CAAC;AACf,KAAA;SAAM,IAAI,cAAc,IAAI,KAAK,EAAE;AAClC,QAAA,OAAO,EAAE,GAAG,KAAK,CAAC,YAAY,CAAC;AAChC,KAAA;SAAM,IAAI,cAAc,IAAI,KAAK,EAAE;AAClC,QAAA,OAAO,EAAE,GAAG,KAAK,CAAC,YAAY,CAAC;AAChC,KAAA;SAAM,IAAI,aAAa,IAAI,KAAK,EAAE;AACjC,QAAA,OAAO,EAAE,GAAG,KAAK,CAAC,WAAW,CAAC;AAC/B,KAAA;SAAM,IAAI,gBAAgB,IAAI,KAAK,EAAE;AACpC,QAAA,OAAO,iBAAiB,CAAC,KAAK,CAAC,cAAe,CAAC,CAAC;AACjD,KAAA;SAAM,IAAI,aAAa,IAAI,KAAK,EAAE;QACjC,OAAO,KAAK,CAAC,WAAY,CAAC;AAC3B,KAAA;SAAM,IAAI,YAAY,IAAI,KAAK,EAAE;AAChC,QAAA,OAAO,kBAAkB,CAAC,KAAK,CAAC,UAAW,CAAC,CAAC;AAC9C,KAAA;SAAM,IAAI,gBAAgB,IAAI,KAAK,EAAE;QACpC,OAAO,KAAK,CAAC,cAAe,CAAC;AAC9B,KAAA;SAAM,IAAI,eAAe,IAAI,KAAK,EAAE;AACnC,QAAA,OAAO,gBAAgB,CAAC,KAAK,CAAC,aAAc,CAAC,CAAC;AAC/C,KAAA;SAAM,IAAI,YAAY,IAAI,KAAK,EAAE;AAChC,QAAA,OAAO,aAAa,CAAC,KAAK,CAAC,UAAW,CAAC,CAAC;AACzC,KAAA;SAAM,IAAI,UAAU,IAAI,KAAK,EAAE;AAC9B,QAAA,OAAO,WAAW,CAAC,KAAK,CAAC,QAAS,CAAC,CAAC;AACrC,KAAA;AAAM,SAAA;AACL,QAAA,MAAM,IAAI,KAAK,CAAC,sBAAsB,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;AACjE,KAAA;AACH,CAAC;AACD;AAGA,SAAS,kBAAkB,CAAC,UAA+B,EAAA;IACzD,IAAI,OAAO,UAAU,KAAK,QAAQ;AAAE,QAAA,OAAO,UAAU,CAAC;AACtD,IAAA,OAAO,UAAU,CAAC,QAAQ,EAAE,CAAC;AAC/B,CAAC;AAID,SAAS,iBAAiB,CAAC,SAAoB,EAAA;AAC7C,IAAA,OAAO,QAAQ,SAAS,CAAC,QAAQ,EAAE,GAAG,CAAC;AACzC,CAAC;AAED,SAAS,gBAAgB,CAAC,QAAgB,EAAA;IACxC,OAAO,CAAA,IAAA,EAAO,QAAQ,CAAC,QAAQ,IAAI,QAAQ,CAAC,SAAS,CAAA,CAAA,CAAG,CAAC;AAC3D,CAAC;AAED,SAAS,WAAW,CAAC,QAAkB,EAAA;;;AAGrC,IAAA,MAAM,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,IAAI,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC;;AAE7D,IAAA,MAAM,OAAO,GAAG,UAAU,CAAC,GAAG,CAAC,GAAG,IAAI,CAAG,EAAA,GAAG,CAAI,CAAA,EAAA,aAAa,CAAC,QAAQ,CAAC,MAAO,CAAC,GAAG,CAAC,CAAC,CAAE,CAAA,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IAClG,OAAO,CAAA,CAAA,EAAI,OAAO,CAAA,CAAA,CAAG,CAAC;AACxB,CAAC;AAED,SAAS,aAAa,CAAC,UAAsB,EAAA;AAC3C,IAAA,MAAM,MAAM,GAAG,UAAU,CAAC,MAAM,IAAI,EAAE,CAAC;AACvC,IAAA,OAAO,CAAI,CAAA,EAAA,MAAM,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;AACpD;;MC7Ga,gBAAgB,CAAA;AAD7B,IAAA,WAAA,GAAA;QAEU,IAAS,CAAA,SAAA,GAAyC,EAAE,CAAC;AACrD,QAAA,IAAA,CAAA,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;AAC5B,QAAA,IAAA,CAAA,WAAW,GAAG,MAAM,CAAC,WAAW,CAAC,CAAC;;QAElC,IAAa,CAAA,aAAA,GAAG,MAAM,CAAC,aAAa,EAAE,WAAW,CAAC,QAAQ,CAAC,CAAC;;AAE5D,QAAA,IAAA,CAAA,KAAK,GAA2C,IAAI,GAAG,EAAE,CAAC;AAgJnE,KAAA;AA9IC,IAAA,IAAI,EAAE,GAAA;QACJ,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;KACrC;;IAGD,QAAQ,CACN,GAA6D,EAC7D,IAAiB,EAAA;AAEjB,QAAA,IAAI,eAAe,CAAC,GAAG,CAAC,EAAE;YACvB,IAAyB,CAAC,OAAO,CAAC,GAAG,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,CAAC;YAC7E,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAChC,SAAA;AAAM,aAAA,IAAI,OAAO,CAAC,GAAG,CAAC,EAAE;YACtB,IAAyB,CAAC,OAAO,CAAC,GAAG,IAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,CAAC;AAC7E,YAAA,MAAM,GAAG,GAAG,cAAc,CAAC,GAAU,CAAC,CAAC;YACvC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;AAC3B,SAAA;AAAM,aAAA;YACL,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AAChC,SAAA;KACF;AAMD,IAAA,QAAQ,CAAI,GAA6D,EAAA;AACvE,QAAA,IAAI,OAAO,CAAC,GAAG,CAAC,EAAE;AAChB,YAAA,MAAM,GAAG,GAAG,cAAc,CAAC,GAAU,CAAC,CAAC;YACvC,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAgB,CAAC;AAC3C,SAAA;AAAM,aAAA;YACL,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAgB,CAAC;AAChD,SAAA;KACF;IAOD,UAAU,CACR,GAA6D,EAC7D,KAAc,EAAA;AAEd,QAAA,MAAM,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,GAAG,cAAc,CAAC,GAAU,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC;AACjE,QAAA,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE;AACxB,YAAA,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,OAAO,CAAC,GAAU,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC;AACvE,SAAA;AACD,QAAA,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAA4B,CAAC;KACvD;AAUD,IAAA,WAAW,CAAI,GAA6D,EAAA;QAC1E,IAAI,CAAC,IAAI,CAAC,aAAa,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,WAAW,CAAC;YAAE,OAAO;AACxE,QAAA,MAAM,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,GAAG,cAAc,CAAC,GAAU,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC;AACjE,QAAA,MAAM,QAAQ,GAAG,YAAY,CAAI,GAAG,CAAC,CAAC;QACtC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,QAAQ,CAAC;YAAE,OAAO;AACjD,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;AAC1D,QAAA,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;AACpC,QAAA,OAAO,KAAK,CAAC;KACd;IAMD,WAAW,CAAI,GAAsF,EAAE,KAAe,EAAA;AACpH,QAAA,IAAI,CAAC,KAAK;YAAE,OAAO;QACnB,IAAI,CAAC,IAAI,CAAC,aAAa,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,WAAW,CAAC;YAAE,OAAO;AACvE,QAAA,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;YAC9C,GAAG,CAAC,OAAO,CAAC,CAAC,SAAS,EAAE,CAAC,KAAK,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACtE,SAAA;AAAM,aAAA,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;AAC9B,YAAA,MAAM,GAAG,GAAG,OAAO,CAAC,GAAG,CAAC,GAAG,cAAc,CAAC,GAAU,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC;AACjE,YAAA,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,YAAY,CAAM,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC;AACvD,SAAA;KACF;AAGD,IAAA,UAAU,CAAC,KAAgC,EAAA;AACzC,QAAA,IAAI,CAAC,KAAK;YAAE,OAAO;AACnB,QAAA,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;AACxB,YAAA,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;AACxB,gBAAA,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;AAC5B,gBAAA,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AACzB,aAAA;AACF,SAAA;AAAM,aAAA,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;AACpC,YAAA,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;AAC7B,YAAA,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;AAC1B,SAAA;AAAM,aAAA;AACL,YAAA,MAAM,GAAG,GAAG,cAAc,CAAC,KAAK,CAAC,CAAC;AAClC,YAAA,OAAO,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;AAC3B,YAAA,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;AACxB,SAAA;KACF;;IAOM,MAAM,CACX,KAAwB,EACxB,WAA+B,EAAA;AAE/B,QAAA,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI,CAAC,KAAK;AAAE,YAAA,OAAO,SAAS,CAAC;;AAGlD,QAAA,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;AACxB,YAAA,OAAO,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,MAAM,CAAI,IAAI,CAAyB,CAAC,CAAC;AAC1E,SAAA;QAED,MAAM,aAAa,GAAG,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;AACjD,QAAA,IAAI,aAAa,EAAE;YACjB,UAAU,CAAC,KAAK,CAAC,CAAC;YAClB,gBAAgB,CAAC,KAAK,CAAC,CAAC;YACxB,MAAM,GAAG,GAAG,UAAU,CAAC,IAAI,CAAC,EAAE,EAAE,KAAK,CAA2B,CAAC;AACjE,YAAA,OAAO,KAAK,CAAC,GAAG,EAAE,GAAG,WAAW,CAAC,CAAC;AACnC,SAAA;AAAM,aAAA;YACL,UAAU,CAAC,KAAK,CAAC,CAAC;YAClB,IAAI,SAAS,CAAC,KAAK,CAAC;gBAAE,OAAO,GAAG,CAAC,IAAI,CAAC,EAAE,EAAE,KAAK,CAAyB,CAAC;YACzE,OAAO,UAAU,CAAC,IAAI,CAAC,EAAE,EAAE,KAAK,CAA2B,CAAC;AAC7D,SAAA;KACF;IAED,KAAK,GAAA;AACH,QAAA,OAAO,UAAU,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;KAC5B;AAED,IAAA,cAAc,CAAI,EAA4C,EAAA;AAC5D,QAAA,OAAO,cAAc,CAAI,IAAI,CAAC,EAAE,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;KACnD;IAED,QAAQ,GAAA;AACN,QAAA,OAAO,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC;KAC1C;;8GArJU,gBAAgB,EAAA,IAAA,EAAA,EAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,UAAA,EAAA,CAAA,CAAA;AAAhB,gBAAA,CAAA,KAAA,GAAA,EAAA,CAAA,qBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,SAAA,EAAA,QAAA,EAAA,EAAA,EAAA,IAAA,EAAA,gBAAgB,cADH,MAAM,EAAA,CAAA,CAAA;4FACnB,gBAAgB,EAAA,UAAA,EAAA,CAAA;kBAD5B,UAAU;mBAAC,EAAE,UAAU,EAAE,MAAM,EAAE,CAAA;;;ACZlC;AACgB,SAAA,UAAU,CAAC,IAAY,EAAE,EAAU,EAAA;;AAEjD,IAAA,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,GAAG,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,GAAG,EAAE,GAAG,CAAG,EAAA,IAAI,CAAI,CAAA,EAAA,EAAE,EAAE,CAAC;AAC9E,CAAC;AAED;AACM,SAAU,MAAM,CAAI,MAAS,EAAA;IACjC,IAAI,OAAO,MAAM,KAAK,QAAQ;AAAE,QAAA,OAAO,MAAM,CAAC;AAC9C,IAAA,KAAK,MAAM,GAAG,IAAI,MAAM,EAAE;AACxB,QAAA,MAAM,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;AAC1B,QAAA,IAAI,CAAC,KAAK,IAAI,OAAO,KAAK,KAAK,QAAQ;YAAE,SAAS;QAClD,IAAI,KAAK,YAAY,SAAS,EAAE;YAC9B,MAAM,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,MAAM,EAAS,CAAC;YACpC,SAAS;AACV,SAAA;QACD,MAAM,CAAC,KAAK,CAAC,CAAA;AACd,KAAA;AACD,IAAA,OAAO,MAAM,CAAC;AAChB;;ACrBA;AAcA;AACA;AACA;MAEsB,YAAY,CAAA;AAAlC,IAAA,WAAA,GAAA;AACY,QAAA,IAAA,CAAA,UAAU,GAAG,MAAM,CAAC,WAAW,CAAC,CAAC;AACjC,QAAA,IAAA,CAAA,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC;AACtB,QAAA,IAAA,CAAA,SAAS,GAAG,MAAM,CAAC,gBAAgB,CAAC,CAAC;QAErC,IAAK,CAAA,KAAA,GAAgB,IAAW,CAAC;;QAEjC,IAAO,CAAA,OAAA,GAAG,KAAK,CAAC;AAC1B;;AAEG;QACO,IAAQ,CAAA,QAAA,GAAG,KAAK,CAAC;AAC3B;;;AAGG;QACO,IAAkB,CAAA,kBAAA,GAAG,CAAC,CAAC;KA6NlC;AAtNC,IAAA,IAAc,EAAE,GAAA;AACd,QAAA,OAAO,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC;KAC1B;AAES,IAAA,QAAQ,CAAc,GAAyB,EAAA;AACvD,QAAA,IAAI,gBAAgB,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;YACrC,OAAO,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,CACzD,SAAS,CAAC,OAAM,IAAI,KAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,EAC9C,GAAG,CAAC,KAAK,IAAI,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,EACpD,sBAAsB,CAAC,IAAI,CAAC,IAAI,CAAC,CAClC,CAAC;AACH,SAAA;AACD,QAAA,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;AAClB,YAAA,OAAO,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,CACzD,SAAS,CAAC,OAAM,IAAI,KAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,EAC9C,sBAAsB,CAAC,IAAI,CAAC,IAAI,CAAC,CAClC,CAAC;AACH,SAAA;QACD,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;QACjD,MAAM,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;QAC7C,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,MAAM,IAAI,CAAC,SAAS,CAAC,UAAU,CAAI,GAAG,EAAE,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAC9G,GAAG,CAAC,IAAI,IAAI,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,EAC/C,sBAAsB,CAAC,IAAI,CAAC,IAAI,CAAC,CAClC,CAAC;AACF,QAAA,IAAI,QAAQ;YAAE,OAAO,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,OAAM,IAAI,KAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,EAAE,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC;AACrG,QAAA,IAAI,OAAO;YAAE,OAAO,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,EAAE,SAAS,CAAC,OAAM,IAAI,KAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACnG,OAAO,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,OAAM,IAAI,KAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;KACnE;AAES,IAAA,UAAU,CAAc,GAAyB,EAAA;QACzD,OAAO,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;KAC5C;;IAGS,WAAW,CAAkB,MAAqB,EAAE,UAA+B,EAAA;QAC3F,IAAI,UAAU,KAAK,QAAQ,EAAE;AAC3B,YAAA,MAAM,KAAK,GAAiB,EAAE,SAAS,EAAE,IAAI,IAAI,EAAE,EAAE,UAAU,EAAE,IAAI,IAAI,EAAE,EAAE,CAAC;AAC9E,YAAA,OAAO,EAAE,KAAK,EAAE,GAAG,MAAM,EAAE,CAAC;AAC7B,SAAA;AAAM,aAAA;YACL,OAAO,EAAE,GAAG,MAAM,EAAE,kBAAkB,EAAE,IAAI,IAAI,EAAE,EAAE,CAAC;AACtD,SAAA;KACF;;AAGS,IAAA,aAAa,CAAkB,QAAwD,EAAA;AAC/F,QAAA,IAAI,QAAQ,CAAC,MAAM,EAAE,EAAE;YACrB,OAAO,EAAE,GAAG,MAAM,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,GAAG,QAAQ,CAAC,EAAE,EAAE,CAAC;AAClE,SAAA;AAAM,aAAA;AACL,YAAA,OAAO,SAAS,CAAC;AAClB,SAAA;KACF;IAED,KAAK,GAAA;AACH,QAAA,OAAO,UAAU,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;KAC5B;AAED,IAAA,cAAc,CAAI,EAA4C,EAAA;AAC5D,QAAA,OAAO,cAAc,CAAI,IAAI,CAAC,EAAE,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;KACnD;AAED,IAAA,QAAQ,CAAC,MAAe,EAAA;QACtB,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,CAAC;KAChC;;AAIS,IAAA,UAAU,CAAkB,IAAyB,EAAA;AAC7D,QAAA,OAAO,IAAI,CAAC,aAAa,CAAI,IAAI,CAAC,CAAC;KACpC;;IAGS,MAAM,UAAU,CAAkB,GAAyB,EAAA;AACnE,QAAA,MAAM,IAAI,GAAG,MAAM,MAAM,CAAC,GAAG,CAAC,CAAC;AAC/B,QAAA,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;KAC9B;;AAGS,IAAA,OAAO,CAAkB,GAAyB,EAAA;AAC1D,QAAA,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;KAC3B;;;;;AAOM,IAAA,MAAM,CAAc,UAAmB,EAAA;QAC5C,MAAM,IAAI,GAAG,UAAU,GAAG,cAAc,CAAC,IAAI,CAAC,IAAI,EAAE,UAAU,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC;QAC5E,MAAM,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAI,IAAI,CAAyB,CAAC;AACnE,QAAA,IAAI,CAAC,GAAG;AAAE,YAAA,MAAM,IAAI,KAAK,CAAC,6CAA6C,IAAI,CAAA,CAAA,CAAG,CAAC,CAAC;AAChF,QAAA,OAAO,GAAG,CAAC;KACZ;;IAGM,MAAM,MAAM,CAAkB,UAAmB,EAAA;QACtD,IAAI,CAAC,IAAI,CAAC,QAAQ;YAAE,OAAO;QAC3B,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;AACpC,QAAA,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AACrB,QAAA,OAAO,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;KAC9B;;IAGM,MAAM,IAAI,CAAc,UAAmB,EAAA;QAChD,OAAO,cAAc,CAAC,IAAI,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC;KACtD;;IAGM,MAAM,QAAQ,CAAkB,UAAmB,EAAA;QACxD,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAI,UAAU,CAAC,CAAC;AACvC,QAAA,OAAO,IAAI,CAAC,UAAU,CAAI,GAAG,CAAC,CAAC;KAChC;;AAGM,IAAA,YAAY,CAAkB,UAAmB,EAAA;QACtD,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAI,UAAU,CAAC,CAAC;AACvC,QAAA,OAAO,IAAI,CAAC,OAAO,CAAI,GAAG,CAAC,CAAC;KAC7B;;;;AAMD;;;;AAIG;AACH,IAAA,MAAM,MAAM,CAAc,QAAuB,EAAE,UAAwB,EAAE,EAAA;QAC3E,MAAM,EAAE,GAAoC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QACjE,IAAI,OAAO,EAAE,KAAK,QAAQ;YAAE,OAAO,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QAClE,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QACxC,MAAM,IAAI,GAAG,CAAC,OAAO,EAAE,KAAK,YAAY,WAAW;cAC/C,MAAM,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,GAAG,CAAC;AAC/B,cAAE,MAAM,MAAM,CAAC,GAAG,CAAC,CAAC;QACtB,IAAI,IAAI,CAAC,MAAM,EAAE;YAAE,OAAO,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QACzD,MAAM,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;AACrC,QAAA,OAAO,EAAE,CAAC;KACX;AAED;;;;AAIG;AACH,IAAA,MAAM,MAAM,CAAc,QAAuB,EAAE,UAAwB,EAAE,EAAA;QAC3E,MAAM,MAAM,GAAoC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AACrE,QAAA,MAAM,EAAE,GAAG,OAAO,MAAM,KAAK,QAAQ,GAAG,MAAM,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;QACjE,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QACxD,IAAI,IAAI,CAAC,OAAO;AAAE,YAAA,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;QACxC,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QACxC,IAAI,OAAO,CAAC,KAAK,EAAE;YAChB,OAAO,CAAC,KAAoB,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;AAC9C,SAAA;AAAM,aAAA;AACL,YAAA,MAAM,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;AACzB,SAAA;QACD,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,MAAM,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,EAAE,KAAK,EAAE,OAAO,CAAC,KAAK,EAAE,GAAG,EAAE,OAAO,CAAC,GAAG,EAAE,CAAC,CAAC;AACvE,SAAA;AACD,QAAA,OAAO,EAAE,CAAC;KACX;AAED;;;AAGG;AACH,IAAA,MAAM,MAAM,CAAc,OAAA,GAAwB,EAAE,EAAA;AAClD,QAAA,MAAM,EAAE,KAAK,GAAG,IAAI,CAAC,KAAK,EAAE,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,OAAO,CAAC;QACtD,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAI,MAAM,CAAC,CAAC;AACnC,QAAA,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;QAClB,IAAI,IAAI,CAAC,QAAQ,EAAE;AACjB,YAAA,MAAM,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,EAAE,KAAK,EAAE,GAAG,EAAE,CAAC,CAAC;AAC/C,SAAA;;AAED,QAAA,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE;AAClB,YAAA,MAAO,KAAoB,CAAC,MAAM,EAAE,CAAC;YACrC,IAAI,IAAI,CAAC,QAAQ;AAAE,gBAAA,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AACzC,SAAA;KACF;AAKD,IAAA,MAAM,MAAM,CACV,OAA0C,EAC1C,UAAwB,EAAE,EAAA;QAE1B,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAI,OAAO,CAAC,MAAM,CAAC,CAAC;AAC3C,QAAA,IAAI,OAAO,OAAO,KAAK,UAAU,EAAE;YACjC,MAAM,cAAc,CAAC,IAAI,CAAC,EAAE,EAAE,OAAO,EAAE,KAAI;gBACzC,MAAM,QAAQ,GAAG,MAAM,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;gBACnC,MAAM,GAAG,GAAG,MAAM,IAAI,CAAC,aAAa,CAAI,QAAQ,CAAC,CAAC;gBAClD,IAAI,GAAG,IAAI,OAAO,EAAE;oBAClB,MAAM,IAAI,GAAG,MAAM,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;oBACpC,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;AACtD,oBAAA,EAAE,CAAC,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;oBACvB,IAAI,IAAI,CAAC,QAAQ,EAAE;AACjB,wBAAA,MAAM,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,OAAO,CAAC,GAAG,EAAE,CAAC,CAAC;AAC5D,qBAAA;AACF,iBAAA;AACH,aAAC,CAAC,CAAC;AACJ,SAAA;AAAM,aAAA;YACL,MAAM,GAAG,GAAG,MAAM,IAAI,CAAC,WAAW,CAAI,OAAO,EAAE,QAAQ,CAAC,CAAC;YACzD,IAAI,OAAO,CAAC,KAAK,EAAE;gBAChB,OAAO,CAAC,KAAoB,CAAC,MAAM,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;AAChD,aAAA;AAAM,iBAAA;AACL,gBAAA,MAAM,SAAS,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;AAC3B,aAAA;YACD,IAAI,IAAI,CAAC,QAAQ,EAAE;gBACjB,MAAM,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,EAAE,KAAK,EAAE,OAAO,CAAC,KAAK,EAAE,GAAG,EAAE,OAAO,CAAC,GAAG,EAAE,CAAC,CAAC;AACtE,aAAA;AACF,SAAA;QACD,IAAI,IAAI,CAAC,QAAQ;AAAE,YAAA,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;KAEzC;AACF;;AC/PD;AAcA;AACA;AACA;MAEsB,cAAc,CAAA;AAApC,IAAA,WAAA,GAAA;AACY,QAAA,IAAA,CAAA,UAAU,GAAG,MAAM,CAAC,WAAW,CAAC,CAAC;AACjC,QAAA,IAAA,CAAA,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC;AACtB,QAAA,IAAA,CAAA,SAAS,GAAG,MAAM,CAAC,gBAAgB,CAAC,CAAC;QAErC,IAAK,CAAA,KAAA,GAAgB,IAAW,CAAC;;QAEjC,IAAO,CAAA,OAAA,GAAG,KAAK,CAAC;AAC1B;;AAEG;QACO,IAAQ,CAAA,QAAA,GAAG,KAAK,CAAC;AAC3B;;;AAGG;QACO,IAAkB,CAAA,kBAAA,GAAG,CAAC,CAAC;KAualC;AAhaC,IAAA,IAAc,EAAE,GAAA;AACd,QAAA,OAAO,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC;KAC1B;AAKS,IAAA,QAAQ,CAAc,GAAoC,EAAA;AAClE,QAAA,IAAI,gBAAgB,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;YACrC,OAAO,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,MAAM,OAAO,CAAC,GAAe,CAAC,CAAC,CAAC,IAAI,CACrE,GAAG,CAAC,IAAI,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,EAClC,GAAG,CAAC,KAAK,IAAI,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,EACpD,sBAAsB,CAAC,IAAI,CAAC,IAAI,CAAC,CAClC,CAAC;AACH,SAAA;AACD,QAAA,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;AAClB,YAAA,OAAO,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,MAAM,OAAO,CAAC,GAAe,CAAC,CAAC,CAAC,IAAI,CACrE,GAAG,CAAC,IAAI,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,EAClC,sBAAsB,CAAC,IAAI,CAAC,IAAI,CAAC,CAClC,CAAC;AACH,SAAA;QACD,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;QACjD,MAAM,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;QAC7C,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,MAAM,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,GAAG,EAAE,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC,IAAI,CAC3G,GAAG,CAAC,IAAI,IAAI,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,EAC/C,sBAAsB,CAAC,IAAI,CAAC,IAAI,CAAC,CAClC,CAAC;AACF,QAAA,IAAI,QAAQ;YAAE,OAAO,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,EAAE,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC;AACzF,QAAA,IAAI,OAAO;YAAE,OAAO,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,EAAE,GAAG,CAAC,IAAI,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AACvF,QAAA,OAAO,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;KACvD;AAES,IAAA,UAAU,CAAc,IAAuF,EAAA;AACvH,QAAA,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC;AAAE,YAAA,OAAO,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;QACrF,IAAI,OAAO,CAAC,IAAI,CAAC;YAAE,OAAO,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;QAC1D,OAAO,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;KAC9C;;IAGS,WAAW,CAAC,MAAqB,EAAE,UAA4B,EAAA;QACvE,IAAI,UAAU,KAAK,KAAK,EAAE;AACxB,YAAA,MAAM,KAAK,GAAiB,EAAE,SAAS,EAAE,IAAI,IAAI,EAAE,EAAE,UAAU,EAAE,IAAI,IAAI,EAAE,EAAE,CAAC;AAC9E,YAAA,OAAO,EAAE,KAAK,EAAE,GAAG,MAAM,EAAE,CAAC;AAC7B,SAAA;AAAM,aAAA;YACL,OAAO,EAAE,GAAG,MAAM,EAAE,kBAAkB,EAAE,IAAI,IAAI,EAAE,EAAE,CAAC;AACtD,SAAA;KACF;;AAGS,IAAA,aAAa,CAAC,QAAwD,EAAA;AAC9E,QAAA,IAAI,QAAQ,CAAC,MAAM,EAAE,EAAE;YACrB,OAAO,EAAE,GAAG,MAAM,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,GAAG,QAAQ,CAAC,EAAE,EAAE,CAAC;AAClE,SAAA;AAAM,aAAA;AACL,YAAA,OAAO,SAAS,CAAC;AAClB,SAAA;KACF;IAED,KAAK,GAAA;AACH,QAAA,OAAO,UAAU,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;KAC5B;AAED,IAAA,cAAc,CAAI,EAA4C,EAAA;AAC5D,QAAA,OAAO,cAAc,CAAI,IAAI,CAAC,EAAE,EAAE,CAAC,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;KACnD;IAED,QAAQ,GAAA;AACN,QAAA,OAAO,GAAG,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC;KAC1C;AAQS,IAAA,UAAU,CAAkB,IAAoE,EAAA;QACxG,IAAI,IAAI,YAAY,gBAAgB;AAAE,YAAA,OAAO,IAAI,CAAC,aAAa,CAAC,IAAI,CAAM,CAAC;AAC3E,QAAA,MAAM,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACrD,OAAO,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC;KAClE;IASS,MAAM,UAAU,CACxB,GAAsF,EAAA;AAEtF,QAAA,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC;YAAE,OAAO,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;QAClG,MAAM,IAAI,GAAG,CAAC,GAAG,CAAC,IAAI,KAAK,UAAU,IAAI,MAAM,MAAM,CAAC,GAAG,CAAC,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC;AAChF,QAAA,OAAO,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;KAC9B;AASS,IAAA,OAAO,CACf,GAAsF,EAAA;AAEtF,QAAA,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;YACtB,IAAI,CAAC,GAAG,CAAC,MAAM;AAAE,gBAAA,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC;AAC/B,YAAA,MAAM,OAAO,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;AAC/C,YAAA,OAAO,aAAa,CAAC,OAAO,CAAC,CAAC;AAC/B,SAAA;AAAM,aAAA;AACL,YAAA,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;AAC3B,SAAA;KACF;IAiBM,MAAM,CACX,GAAoD,EACpD,UAAmB,EAAA;;QAGnB,IAAI,CAAC,SAAS,CAAC,MAAM;YAAE,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;;AAE/D,QAAA,IAAI,CAAC,GAAG;AAAE,YAAA,OAAO,SAAS,CAAC;AAE3B,QAAA,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;;AAEtB,YAAA,IAAK,GAAa,CAAC,KAAK,CAAC,SAAS,CAAC;gBAAE,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,GAAe,CAAC,CAAC;YAEnF,MAAM,IAAI,GAAG,cAAc,CAAC,IAAI,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;;YAEnD,IAAI,QAAQ,CAAC,GAAG,CAAC;gBAAE,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE,KAAK,UAAU,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;;YAEvF,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;AACzC,SAAA;AAED,QAAA,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;;YAE3B,IAAI,SAAS,CAAC,GAAG,CAAC;gBAAE,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;;YAEtD,MAAM,IAAI,GAAG,cAAc,CAAC,IAAI,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;AACnD,YAAA,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,CAAC;AACrD,SAAA;;AAGD,QAAA,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC,CAAC;KAC9D;AAUM,IAAA,MAAM,MAAM,GAAA;QACjB,IAAI,CAAC,IAAI,CAAC,QAAQ;YAAE,OAAO;QAC3B,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,SAAS,CAAC,CAAC;AACtC,QAAA,IAAI,CAAC,GAAG;YAAE,OAAO;AACjB,QAAA,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AACrB,QAAA,OAAO,IAAI,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC;KAChC;AASM,IAAA,MAAM,IAAI,GAAA;QACf,OAAO,cAAc,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC;KACxD;AAOM,IAAA,MAAM,QAAQ,GAAA;QACnB,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAI,GAAG,SAAS,CAAC,CAAC;AACzC,QAAA,IAAI,CAAC,GAAG;YAAE,OAAO;AACjB,QAAA,OAAO,IAAI,CAAC,UAAU,CAAI,GAAG,CAAC,CAAC;KAChC;AASM,IAAA,YAAY,CACjB,SAAwD,EAAA;QAExD,IAAI,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM;AAAE,YAAA,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC;QACjE,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAI,GAAG,SAAS,CAAC,CAAC;AACzC,QAAA,IAAI,CAAC,GAAG;AAAE,YAAA,OAAO,EAAE,CAAC,SAAS,CAAC,CAAC;AAC/B,QAAA,OAAO,IAAI,CAAC,OAAO,CAAI,GAAG,CAAC,CAAC;KAC7B;AAaD,IAAA,MAAM,MAAM,CACV,SAA0C,EAC1C,UAAwB,EAAE,EAAA;AAE1B,QAAA,MAAM,SAAS,GAAG,OAAO,GAAkB,KAAI;YAC7C,MAAM,EAAE,GAAoC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YAC5D,IAAI,OAAO,EAAE,KAAK,QAAQ;AAAE,gBAAA,OAAO,KAAK,CAAC;AACzC,YAAA,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,EAAE,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC;YAC5C,MAAM,IAAI,GAAG,CAAC,OAAO,CAAC,KAAK,YAAY,WAAW;kBAC9C,MAAM,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,GAAG,CAAC;AAC/B,kBAAE,MAAM,MAAM,CAAC,GAAG,CAAC,CAAC;AACtB,YAAA,OAAO,IAAI,CAAC,MAAM,EAAE,CAAC;AACvB,SAAC,CAAC;AACF,QAAA,MAAM,MAAM,GAAG,OAAO,GAAkB,KAAI;AAC1C,YAAA,MAAM,MAAM,GAAG,MAAM,SAAS,CAAC,GAAG,CAAC,CAAC;AACpC,YAAA,IAAI,CAAC,MAAM;gBAAE,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;YAC3C,MAAM,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;AAChC,YAAA,OAAO,GAAG,CAAC,IAAI,CAAC,KAAK,CAAW,CAAC;AACnC,SAAC,CAAA;AACD,QAAA,OAAO,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC;cAC3B,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;AACpC,cAAE,MAAM,CAAC,SAAS,CAAC,CAAC;KACvB;AASD,IAAA,MAAM,GAAG,CACP,SAA0C,EAC1C,UAAwB,EAAE,EAAA;AAE1B,QAAA,MAAM,IAAI,GAAG,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,GAAG,SAAS,GAAG,CAAC,SAAS,CAAC,CAAC;AAChE,QAAA,MAAM,EAAE,KAAK,GAAG,IAAI,CAAC,KAAK,EAAE,EAAE,GAAG,EAAE,GAAG,OAAO,CAAC;QAC9C,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,KAAK,KAAI;AAC1C,YAAA,MAAM,EAAE,GAAI,KAAK,CAAC,IAAI,CAAC,KAAK,CAAwB,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;YACxE,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;YAClD,IAAI,IAAI,CAAC,OAAO;AAAE,gBAAA,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;AACxC,YAAA,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,EAAE,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC;AAC3C,YAAA,KAAoB,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;YACrC,IAAI,IAAI,CAAC,QAAQ,EAAE;AACjB,gBAAA,MAAM,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,EAAE,KAAK,EAAE,GAAG,EAAE,CAAC,CAAC;AAC3C,aAAA;AACD,YAAA,OAAO,EAAE,CAAC;AACZ,SAAC,CAAC,CAAC;QACH,MAAM,GAAG,GAAa,MAAM,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;;AAEpD,QAAA,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE;AAClB,YAAA,MAAO,KAAoB,CAAC,MAAM,EAAE,CAAC;AACtC,SAAA;AACD,QAAA,OAAO,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,CAAC;KAChD;AAED;;;;AAIG;AACH,IAAA,MAAM,MAAM,CAAc,EAAqB,EAAE,UAAwB,EAAE,EAAA;AACzE,QAAA,MAAM,EAAE,KAAK,GAAG,IAAI,CAAC,KAAK,EAAE,EAAE,GAAG,EAAE,GAAG,OAAO,CAAC;AAC9C,QAAA,MAAM,GAAG,GAAa,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,CAAC;QACpD,MAAM,IAAI,GAA2B,EAAE,CAAC;QACxC,MAAM,UAAU,GAAG,GAAG,CAAC,GAAG,CAAC,OAAO,KAAK,KAAI;AACzC,YAAA,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAI,KAAK,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC;AAClD,YAAA,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;YAClB,IAAI,IAAI,CAAC,QAAQ,EAAE;AACjB,gBAAA,MAAM,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,EAAE,KAAK,EAAE,GAAG,EAAE,CAAC,CAAC;AAC5C,aAAA;AACD,YAAA,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AACjB,SAAC,CAAC,CAAC;AACH,QAAA,MAAM,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;;AAE9B,QAAA,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE;AAClB,YAAA,MAAO,KAAoB,CAAC,MAAM,EAAE,CAAC;YACrC,IAAI,IAAI,CAAC,QAAQ;AAAE,gBAAA,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;AAC1C,SAAA;KACF;;AAGD,IAAA,MAAM,SAAS,CAAC,OAAA,GAAwB,EAAE,EAAA;QACxC,MAAM,GAAG,GAAG,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;AACzE,QAAA,MAAM,QAAQ,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC;AACpC,QAAA,MAAM,GAAG,GAAG,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,GAAG,CAAC,EAAE,CAAC,CAAC;QAC/C,MAAM,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;QAChC,IAAI,IAAI,CAAC,QAAQ;AAAE,YAAA,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;KACzC;IAYD,MAAM,MAAM,CACV,WAAgE,EAChE,cAAiE,EACjE,UAAwB,EAAE,EAAA;QAE1B,IAAI,GAAG,GAAa,EAAE,CAAC;AACvB,QAAA,IAAI,aAA4C,CAAC;AACjD,QAAA,IAAI,OAAyC,CAAC;AAE9C,QAAA,MAAM,QAAQ,GAAG,CAAC,KAA4B,KAA4B;YACxE,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AACxD,SAAC,CAAC;AACF,QAAA,MAAM,aAAa,GAAG,CAAC,MAAwC,KAA+B;YAC5F,OAAO,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,MAAM,CAAC,KAAK,CAAC,CAAC,KAAK,KAAK,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;AAC3E,SAAC,CAAC;AAEF,QAAA,IAAI,QAAQ,CAAC,WAAW,CAAC,EAAE;YACzB,GAAG,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAW,CAAC,CAAC;AAC1C,YAAA,OAAO,GAAG,MAAM,WAAW,CAAC;AAC5B,YAAA,OAAO,GAAI,cAA+B,IAAI,EAAE,CAAC;AAClD,SAAA;AAAM,aAAA,IAAI,aAAa,CAAC,WAAW,CAAC,EAAE;YACrC,MAAM,SAAS,GAAG,IAAI,GAAG,CACvB,WAAW,CAAC,GAAG,CAAC,CAAC,MAAM,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAW,EAAE,MAAM,CAAC,CAAC,CACpE,CAAC;YACF,GAAG,GAAG,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC;AACnC,YAAA,OAAO,GAAG,CAAC,KAAK,KAAK,SAAS,CAAC,GAAG,CAAC,KAAK,CAAE,CAAC;AAC3C,YAAA,OAAO,GAAI,cAA+B,IAAI,EAAE,CAAC;AAClD,SAAA;AAAM,aAAA,IAAI,OAAO,cAAc,KAAK,UAAU,EAAE;AAC/C,YAAA,GAAG,GAAG,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,GAAG,WAAW,GAAG,CAAC,WAAW,CAAC,CAAC;YAC/D,aAAa,GAAG,cAAmC,CAAC;AACrD,SAAA;AAAM,aAAA,IAAI,OAAO,cAAc,KAAK,QAAQ,EAAE;AAC7C,YAAA,GAAG,GAAG,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,GAAG,WAAW,GAAG,CAAC,WAAW,CAAC,CAAC;AAC/D,YAAA,OAAO,GAAG,MAAM,cAA+B,CAAC;AACjD,SAAA;AAAM,aAAA;AACL,YAAA,MAAM,IAAI,KAAK,CAAC,0DAA0D,CAAC,CAAC;AAC7E,SAAA;AAED,QAAA,MAAM,EAAE,GAAG,EAAE,GAAG,OAAO,CAAC;AACxB,QAAA,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE;YACtC,OAAO;AACR,SAAA;;AAGD,QAAA,IAAI,aAAa,EAAE;YACjB,IAAI,IAAI,GAA2B,EAAE,CAAC;YACtC,MAAM,cAAc,CAAC,IAAI,CAAC,EAAE,EAAE,OAAO,EAAE,KAAI;gBACzC,IAAI,GAAG,EAAE,CAAC;gBACV,MAAM,UAAU,GAAG,GAAG,CAAC,GAAG,CAAC,OAAO,EAAE,KAAI;AACtC,oBAAA,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAI,EAAE,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC;AAC/C,oBAAA,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;oBACf,MAAM,QAAQ,GAAG,MAAM,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;oBACnC,MAAM,GAAG,GAAG,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;oBACzC,IAAI,GAAG,IAAI,aAAa,EAAE;wBACxB,MAAM,IAAI,GAAG,MAAM,aAAa,CAAC,GAAQ,EAAE,EAAE,CAAC,CAAC;wBAC/C,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;AACtD,wBAAA,EAAE,CAAC,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;wBACvB,IAAI,IAAI,CAAC,QAAQ,EAAE;AACjB,4BAAA,MAAM,IAAI,CAAC,QAAQ,CAAC,IAAI,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,CAAC;AAC/C,yBAAA;AACF,qBAAA;AACD,oBAAA,OAAO,EAAE,CAAC;AACZ,iBAAC,CAAC,CAAC;AACH,gBAAA,OAAO,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;AACjC,aAAC,CAAC,CAAC;YACH,IAAI,IAAI,CAAC,QAAQ;AAAE,gBAAA,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;AAC1C,SAAA;AAAM,aAAA;YACL,MAAM,EAAE,KAAK,GAAG,IAAI,CAAC,KAAK,EAAE,EAAE,GAAG,OAAO,CAAC;YACzC,MAAM,IAAI,GAA2B,EAAE,CAAC;YACxC,MAAM,UAAU,GAAG,GAAG,CAAC,GAAG,CAAC,OAAO,KAAK,KAAI;AACzC,gBAAA,MAAM,GAAG,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC;gBAC3B,IAAI,CAAC,KAAK,EAAE;AACV,oBAAA,MAAM,IAAI,KAAK,CAAC,0EAA0E,GAAG,CAAA,CAAE,CAAC,CAAC;AAClG,iBAAA;AACD,gBAAA,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAI,KAAK,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC;AAClD,gBAAA,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gBACf,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;AAClD,gBAAA,KAAoB,CAAC,MAAM,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;gBACxC,IAAI,IAAI,CAAC,QAAQ,EAAE;AACjB,oBAAA,MAAM,IAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,EAAE,KAAK,EAAE,GAAG,EAAE,CAAC,CAAC;AAC1C,iBAAA;AACH,aAAC,CAAC,CAAC;AACH,YAAA,MAAM,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;;AAE9B,YAAA,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE;AAClB,gBAAA,MAAO,KAAoB,CAAC,MAAM,EAAE,CAAC;gBACrC,IAAI,IAAI,CAAC,QAAQ;AAAE,oBAAA,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAA;AACzC,aAAA;AACF,SAAA;KACF;AACF;;AChcK,MAAgB,iBAA0C,SAAQ,cAAiB,CAAA;AAAzF,IAAA,WAAA,GAAA;;QAEY,IAAO,CAAA,OAAA,GAAG,MAAM,CAAC;KA+H5B;AA7HC,IAAA,IAAI,OAAO,GAAA;QACT,OAAO,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,EAAY,CAAC;KAC7C;;AAGS,IAAA,aAAa,CAAC,QAAwD,EAAA;AAC9E,QAAA,IAAI,QAAQ,CAAC,MAAM,EAAE,EAAE;YACrB,OAAO;AACL,gBAAA,GAAG,MAAM,CAAC,QAAQ,CAAC,IAAI,EAAE,CAAC;AAC1B,gBAAA,CAAC,IAAI,CAAC,KAAK,GAAG,QAAQ,CAAC,EAAE;gBACzB,CAAC,IAAI,CAAC,OAAO,GAAG,QAAQ,CAAC,GAAG,CAAC,IAAI;aAClC,CAAC;AACH,SAAA;AAAM,aAAA;AACL,YAAA,OAAO,SAAS,CAAC;AAClB,SAAA;KACF;AAEM,IAAA,WAAW,CAAkB,WAA+B,EAAA;AACjE,QAAA,MAAM,KAAK,GAAG,eAAe,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,OAAO,CAAa,CAAC;QACjE,IAAI,CAAC,SAAS,CAAC,MAAM;AAAE,YAAA,OAAO,KAAK,CAAC;AACpC,QAAA,IAAI,CAAC,WAAW;YAAE,OAAO;AACzB,QAAA,OAAO,KAAK,CAAC,KAAK,EAAE,GAAG,WAAW,CAAC,CAAC;KACrC;;AAGS,IAAA,YAAY,CAAkB,GAAa,EAAA;AACnD,QAAA,IAAI,gBAAgB,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;AACrC,YAAA,OAAO,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CACvE,sBAAsB,CAAC,IAAI,CAAC,IAAI,CAAC,CAClC,CAAC;AACH,SAAA;AACD,QAAA,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;KAC3B;AAQM,IAAA,MAAM,QAAQ,CACnB,SAAiE,EACjE,MAAe,EAAA;;QAGf,IAAI,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM;AAAE,YAAA,OAAO,EAAE,CAAC;;AAG7D,QAAA,MAAM,OAAO,GAAG,SAAS,CAAC,MAAM,KAAK,CAAC,CAAC;QACvC,MAAM,YAAY,GAAG,SAAS,CAAC,MAAM,KAAK,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;;AAGhG,QAAA,MAAM,GAAG,GAAG,CAAC,OAAO,IAAI,YAAY;AAClC,cAAE,IAAI,CAAC,WAAW,CAAI,GAAG,SAAS,CAAC;cACjC,IAAI,CAAC,MAAM,CAAI,GAAG,SAAS,CAAC,CAAC;AACjC,QAAA,IAAI,CAAC,GAAG;YAAE,OAAO;AACjB,QAAA,OAAO,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;KAC7B;AAOM,IAAA,MAAM,MAAM,CACjB,SAAiE,EACjE,MAAe,EAAA;AAEf,QAAA,MAAM,OAAO,GAAG,SAAS,CAAC,MAAM,KAAK,CAAC,CAAC;QACvC,MAAM,YAAY,GAAG,SAAS,CAAC,MAAM,KAAK,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;AAChG,QAAA,MAAM,GAAG,GAAG,CAAC,OAAO,IAAI,YAAY;AAClC,cAAE,IAAI,CAAC,WAAW,CAAC,GAAG,SAAS,CAAC;cAC9B,IAAI,CAAC,MAAM,CAAC,GAAG,SAAS,CAAC,CAAC;AAC9B,QAAA,IAAI,CAAC,GAAG;YAAE,OAAO;QACjB,IAAI,IAAI,CAAC,QAAQ,EAAE;AACjB,YAAA,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC;AAChB,kBAAE,GAAG,CAAC,OAAO,CAAC,CAAC,IAAI,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;AACtC,kBAAE,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;AAC1B,SAAA;AACD,QAAA,OAAO,IAAI,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC,CAAC;KAChC;IAYM,IAAI,GAAA;QACT,OAAO,cAAc,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,SAAS,CAAC,CAAC,CAAC;KACxD;IAWM,YAAY,CACjB,SAA0D,EAC1D,MAAe,EAAA;;QAGf,IAAI,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM;AAAE,YAAA,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC;;AAGjE,QAAA,MAAM,OAAO,GAAG,SAAS,CAAC,MAAM,KAAK,CAAC,CAAC;QACvC,MAAM,YAAY,GAAG,SAAS,CAAC,MAAM,KAAK,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;;AAGhG,QAAA,MAAM,GAAG,GAAG,CAAC,OAAO,IAAI,YAAY;AAClC,cAAE,IAAI,CAAC,WAAW,CAAI,GAAG,SAAS,CAAC;cACjC,IAAI,CAAC,MAAM,CAAI,GAAG,SAAS,CAAC,CAAC;AAEjC,QAAA,IAAI,CAAC,GAAG;AAAE,YAAA,OAAO,EAAE,CAAC,SAAS,CAAC,CAAC;AAC/B,QAAA,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;KAC1B;AAEF;;AC1ID;;AAEG;;;;"}