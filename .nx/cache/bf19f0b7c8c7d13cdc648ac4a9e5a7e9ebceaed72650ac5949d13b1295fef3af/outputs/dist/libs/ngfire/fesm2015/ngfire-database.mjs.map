{"version":3,"file":"ngfire-database.mjs","sources":["../../../../libs/ngfire/database/src/operators.ts","../../../../libs/ngfire/database/src/tokens.ts","../../../../libs/ngfire/database/src/database.ts","../../../../libs/ngfire/database/src/utils.ts","../../../../libs/ngfire/database/src/list.ts","../../../../libs/ngfire/database/src/ngfire-database.ts"],"sourcesContent":["import {Observable} from 'rxjs';\nimport {delay} from 'rxjs/operators';\nimport {DataSnapshot, onValue} from 'firebase/database';\nimport type {Query} from 'firebase/database';\n\n/**\n * Create an observable from a Database Reference or Database Query.\n * @param query Database Reference\n */\nexport function fromQuery(query: Query): Observable<DataSnapshot> {\n  return new Observable<DataSnapshot>((subscriber) => {\n    const unsubscribe = onValue(\n      query,\n      (snapshot) => subscriber.next(snapshot),\n      subscriber.error.bind(subscriber),\n    );\n    return { unsubscribe };\n  }).pipe(\n      // Ensures subscribe on observable is async. This handles\n      // a quirk in the SDK where on/once callbacks can happen\n      // synchronously.\n      delay(0)\n  );\n}","import { inject, InjectFlags, InjectionToken } from \"@angular/core\";\nimport { Database, getDatabase } from \"firebase/database\";\nimport { FIREBASE_APP } from \"ngfire/app\";\nimport { DB_URL, getConfig } from \"ngfire/tokens\";\n\n\nexport const DATABASE = new InjectionToken<Database>('Database instance', {\n  providedIn: 'root',\n  factory: () => {\n    const config = getConfig();\n    const app = inject(FIREBASE_APP);\n    const url = inject(DB_URL, InjectFlags.Optional);\n    if (config.database) {\n      return config.database(app, url ?? undefined)\n    } else {\n      return getDatabase(app, url ?? undefined);\n    }\n  },\n});\n","import { inject, Injectable, Injector } from \"@angular/core\";\nimport { QueryConstraint, ref as dbRef, remove, set, update, query as queryWithConstraints, DataSnapshot } from 'firebase/database';\nimport type { DatabaseReference, Query } from 'firebase/database';\nimport { Observable } from \"rxjs\";\nimport { Params, assertPath, pathWithParams } from \"ngfire/core\";\nimport { fromQuery } from \"./operators\";\nimport { DATABASE } from \"./tokens\";\n\n\nexport function isContraintList(idsOrQuery: any[]): idsOrQuery is QueryConstraint[] {\n  return idsOrQuery.every(query => query instanceof QueryConstraint);\n}\n\n@Injectable({ providedIn: 'root' })\nexport class FireDatabase {\n  protected injector = inject(Injector);\n  protected memory = new Map<Query, Observable<DataSnapshot>>();\n\n  get db() {\n    return this.injector.get(DATABASE);\n  }\n\n  /** Get the reference of the document, collection or query */\n  public getRef(path: string, params?: Params): DatabaseReference;\n  public getRef(paths: string[], params?: Params): DatabaseReference[];\n  public getRef(path: string, constraints: QueryConstraint[], params?: Params): Query;\n  public getRef(paths: string[], constraints: QueryConstraint[], params?: Params): Query;\n  // overload used internally when looping over paths array\n  public getRef(paths: string, constraints?: Params | QueryConstraint[], params?: Params): Query | DatabaseReference;\n  public getRef(\n    paths: string | string[],\n    paramsOrConstraints?: Params | QueryConstraint[],\n    params?: Params\n  ): undefined | Query | Query[] | DatabaseReference | DatabaseReference[] {\n    if (!arguments.length || !paths) return undefined;\n    const hasContraints = Array.isArray(paramsOrConstraints);\n\n    if (Array.isArray(paths)) {\n      return paths.map((path) => this.getRef(path, paramsOrConstraints, params));\n    }\n\n    if (hasContraints) {\n      const path = pathWithParams(paths, params);\n      assertPath(path);\n      const ref = dbRef(this.db, path);\n      return queryWithConstraints(ref, ...paramsOrConstraints);\n    } else {\n      const path = pathWithParams(paths, paramsOrConstraints);\n      assertPath(path);\n      return dbRef(this.db, path);\n    }\n  }\n\n  fromQuery(query: Query) {\n    let existing: Observable<DataSnapshot> | null = null;\n    for (const [key, value] of this.memory.entries()) {\n      if (query.isEqual(key)) {\n        existing = value;\n        break;\n      }\n    }\n    if (existing) return existing;\n    this.memory.set(query, fromQuery(query));\n    return this.memory.get(query) as Observable<DataSnapshot>;\n  }\n\n  create<T>(path: string, content: T) {\n    return set(this.getRef(path), content);\n  }\n\n  update<T>(path: string, value: Partial<T>) {\n    const ref = this.getRef(path);\n    return update(ref, value);\n  }\n\n  remove(path: string) {\n    const ref = this.getRef(path);\n    return remove(ref);\n  }\n}\n","/** Recursively all Date into Timestamp */\nexport function fromDate<D>(target: D): D {\n  if (typeof target !== 'object') return target;\n  for (const key in target) {\n    const value = target[key];\n    if (!value || typeof value !== 'object') continue;\n    if (value instanceof Date) {\n      target[key] = value.getTime() as any;\n      continue;\n    }\n    fromDate(value)\n  }\n  return target;\n}\n\n/** Recursively all Date into Timestamp */\nexport function toDate<D>(target: D, dateKeys: string[], path: string = ''): D {\n  if (typeof target !== 'object') return target;\n  for (const key in target) {\n    const value = target[key];\n    const deepKey = `${path}.${key}`;\n    if (dateKeys.includes(deepKey)) {\n      if (typeof value !== 'number') throw new Error(`Date key \"${deepKey}\" is not a number. Got ${value}`);\n      target[key] = new Date(value) as any;\n      continue;\n    }\n    if (!value || typeof value !== 'object') continue;\n    toDate(value, dateKeys, deepKey);\n  }\n  return target;\n}\n\n\n","import { inject } from \"@angular/core\";\nimport { DatabaseReference, DataSnapshot, Query, QueryConstraint, set } from \"firebase/database\";\nimport { push, get, remove, update } from \"firebase/database\";\nimport { combineLatest, Observable, of } from \"rxjs\";\nimport { map } from \"rxjs/operators\";\nimport { ExtractDeepKeys, Params, exist, isIdList, pathWithParams } from \"ngfire/core\";\nimport { FireDatabase } from \"./database\";\nimport { serverTimestamp } from 'firebase/database';\nimport { fromDate, toDate } from \"./utils\";\n\ninterface ToDataOptions {\n  isList: boolean;\n}\n\nfunction isListQuery(query?: string | string[] | QueryConstraint[] | Params) {\n  if (typeof query === 'string') return false;\n  if (Array.isArray(query) && isIdList(query)) return false;\n  return true;\n}\n\n\nfunction toKey(value: unknown) {\n  if (typeof value === 'string') return value;\n  if (typeof value === 'number') return value.toString();\n  throw new Error('Key of list should either be a string or a number'); \n}\n\nexport function addMeta(doc: DocumentMeta, actionType: 'add' | 'update') {\n  const _meta: DocumentMeta['_meta'] = doc['_meta'] ?? {};\n  if (actionType === 'add') _meta.createdAt = serverTimestamp() as Date;\n  if (actionType === 'update') _meta.modifiedAt = serverTimestamp() as Date;\n  doc._meta = _meta;\n}\n\nexport interface DocumentMeta {\n  _meta: {\n    createdAt?: Date;\n    modifiedAt?: Date;\n  }\n}\n\nexport abstract class FireList<E> {\n  protected fireDB = inject(FireDatabase);\n  protected abstract readonly path: string;\n  protected abstract dateKeys: ExtractDeepKeys<E, Date>[];\n  protected idKey?: keyof E;\n  protected pathKey?: keyof E;\n\n  protected fromDatabase(snap: DataSnapshot): E | null {\n    if (!snap.exists()) return null;\n    const value = snap.val();\n    \n    const dateKeys = [...this.dateKeys, '_meta.createdAt', '_meta.modifiedAt'];\n    if (!value || typeof value !== 'object') return toDate(value, dateKeys);\n    if (this.idKey) value[this.idKey] = snap.key;\n    if (this.pathKey) value[this.pathKey] = snap.ref.toString();\n    return toDate(value, dateKeys);\n  }\n\n  protected toDatabase(doc: Partial<E>, actionType: 'add' | 'update') {\n    return fromDate(doc); \n  }\n\n  private toData<T extends E = E>(snaps: DataSnapshot | null, options: ToDataOptions): T | null\n  private toData<T extends E = E>(snaps: DataSnapshot[], options: ToDataOptions): T[]\n  private toData<T extends E = E>(snaps: DataSnapshot | DataSnapshot[] | null, options: ToDataOptions): T | T[] | null\n  private toData<T extends E = E>(snaps: DataSnapshot | DataSnapshot[] | null, options: ToDataOptions): T | T[] | null {\n    if (!snaps) return null;\n    if (Array.isArray(snaps)) return snaps.map(snap => this.toData<T>(snap, { isList: false })).filter(exist);\n    if (!options.isList) return this.fromDatabase(snaps) as any;\n    const docs: (T | null)[] = [];\n    // forEach cancels when return value is \"true\". So I return \"false\"\n    snaps.forEach(snap => !docs.push(this.fromDatabase(snap) as any));\n    return docs.filter(exist);\n  }\n\n  getPath(key?: string | Params, params?: Params) {\n    if (typeof key === 'string') return pathWithParams(`${this.path}/${key}`, params);\n    return pathWithParams(this.path, key);\n  }\n\n  getRef(): DatabaseReference\n  getRef(params: Params): DatabaseReference\n  getRef(key: string, params?: Params): DatabaseReference\n  getRef(keys: string[], params?: Params): DatabaseReference[]\n  getRef(constraints: QueryConstraint[], params?: Params): Query\n  // Use internally\n  getRef(query?: string | string[] | QueryConstraint[] | Params, params?: Params): DatabaseReference | DatabaseReference[] | Query\n  getRef(query?: string | string[] | QueryConstraint[] | Params, params?: Params) {\n    // String or Params (getPath return base path is query is Params)\n    if (!Array.isArray(query)) return this.fireDB.getRef(this.getPath(query), params);\n    \n    return isIdList(query)\n      // key list\n      ? this.fireDB.getRef(query.map(key => this.getPath(key)), params)\n      // query constraints\n      : this.fireDB.getRef(this.getPath(), query, params);\n  }\n\n  private fromQuery(): Observable<DataSnapshot>\n  private fromQuery(params: Params): Observable<DataSnapshot>\n  private fromQuery(key: string, params?: Params): Observable<DataSnapshot> | Observable<null>\n  private fromQuery(keys: string[], params?: Params): Observable<DataSnapshot[]>\n  private fromQuery(constraints: QueryConstraint[], params?: Params): Observable<DataSnapshot[]>\n  // Use internally\n  private fromQuery(query?: string | string[] | QueryConstraint[] | Params, params?: Params): Observable<DataSnapshot | DataSnapshot[] | null>\n  private fromQuery(query?: string | string[] | QueryConstraint[] | Params, params?: Params): Observable<DataSnapshot | DataSnapshot[] | null> {\n    const refs = this.getRef(query, params);\n    if (!Array.isArray(refs)) return this.fireDB.fromQuery(refs);\n    const obs = refs.map(ref => this.fireDB.fromQuery(ref));\n    return combineLatest(obs);\n  }\n\n  private getQuery(): Promise<DataSnapshot>\n  private getQuery(params: Params): Promise<DataSnapshot>\n  private getQuery(key: string, params?: Params): Promise<DataSnapshot> | Promise<null>\n  private getQuery(keys: string[], params?: Params): Promise<DataSnapshot[]>\n  private getQuery(constraints: QueryConstraint[], params?: Params): Promise<DataSnapshot[]>\n  // Use internally\n  private getQuery(query?: string | string[] | QueryConstraint[] | Params, params?: Params): Promise<DataSnapshot | DataSnapshot[] | null>\n  private getQuery(query?: string | string[] | QueryConstraint[] | Params, params?: Params): Promise<DataSnapshot | DataSnapshot[] | null> {\n    const refs = this.getRef(query, params);\n    if (!Array.isArray(refs)) return get(refs);\n    const promises = refs.map(ref => get(ref));\n    return Promise.all(promises);\n  }\n\n  valueChanges<T extends E = E>(): Observable<T[]>\n  valueChanges<T extends E = E>(params: Params): Observable<T[]>\n  valueChanges<T extends E = E>(key: string, params?: Params): Observable<T | null>\n  valueChanges<T extends E = E>(keys: string[], params?: Params): Observable<T[]>\n  valueChanges<T extends E = E>(constraints: QueryConstraint[], params?: Params): Observable<T[]>\n  valueChanges<T extends E = E>(query?: string | string[] | QueryConstraint[] | Params, params?: Params): Observable<T | T[] | null> {\n    if (arguments.length && !query) return of(null);\n    return this.fromQuery(query, params).pipe(\n      map(snap => this.toData(snap, { isList: isListQuery(query) })),\n    );\n  }\n\n  getValue<T extends E = E>(): Promise<T[]>\n  getValue<T extends E = E>(params: Params): Promise<T[]>\n  getValue<T extends E = E>(key: string, params?: Params): Promise<T | null>\n  getValue<T extends E = E>(keys: string[], params?: Params): Promise<T[]>\n  getValue<T extends E = E>(constraints: QueryConstraint[], params?: Params): Promise<T[]>\n  async getValue<T extends E = E>(query?: string | string[] | QueryConstraint[] | Params, params?: Params): Promise<T | T[] | null> {\n    if (arguments.length && !query) return Promise.resolve(null);\n    const snap = await this.getQuery(query, params)\n    return this.toData<T>(snap, { isList: isListQuery(query) });\n  }\n\n  add<T extends E>(value: Partial<T>, params?: Params) {\n    const doc = this.toDatabase(value, 'add');\n    if (this.idKey && doc[this.idKey]) {\n      const key = toKey(doc[this.idKey]);\n      const ref = this.getRef(key, params);\n      return set(ref, doc);\n    }\n    const listRef = params ? this.getRef(params) : this.getRef();\n    return push(listRef, doc);\n  }\n\n  update<T extends E>(key: string, value: Partial<T>, params?: Params) {\n    const doc = this.toDatabase(value, 'update');\n    const path = this.getRef(key, params);\n    return update(path, doc);\n  }\n\n  remove(key: string, params?: Params) {\n    const ref = this.getRef(key, params);\n    return remove(ref);\n  }\n\n  /** We use a separated method to avoid mistakes */\n  removeAll(params?: Params) {\n    const ref = params ? this.getRef(params) : this.getRef();\n    return remove(ref);\n  }\n}","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":["ref","dbRef","queryWithConstraints"],"mappings":";;;;;;;;;;AAKA;;;AAGG;AACG,SAAU,SAAS,CAAC,KAAY,EAAA;AACpC,IAAA,OAAO,IAAI,UAAU,CAAe,CAAC,UAAU,KAAI;QACjD,MAAM,WAAW,GAAG,OAAO,CACzB,KAAK,EACL,CAAC,QAAQ,KAAK,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,EACvC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,CAAC,CAClC,CAAC;QACF,OAAO,EAAE,WAAW,EAAE,CAAC;KACxB,CAAC,CAAC,IAAI;;;;AAIH,IAAA,KAAK,CAAC,CAAC,CAAC,CACX,CAAC;AACJ;;MCjBa,QAAQ,GAAG,IAAI,cAAc,CAAW,mBAAmB,EAAE;AACxE,IAAA,UAAU,EAAE,MAAM;IAClB,OAAO,EAAE,MAAK;AACZ,QAAA,MAAM,MAAM,GAAG,SAAS,EAAE,CAAC;AAC3B,QAAA,MAAM,GAAG,GAAG,MAAM,CAAC,YAAY,CAAC,CAAC;QACjC,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE,WAAW,CAAC,QAAQ,CAAC,CAAC;QACjD,IAAI,MAAM,CAAC,QAAQ,EAAE;AACnB,YAAA,OAAO,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,GAAG,KAAH,IAAA,IAAA,GAAG,KAAH,KAAA,CAAA,GAAA,GAAG,GAAI,SAAS,CAAC,CAAA;AAC9C,SAAA;AAAM,aAAA;AACL,YAAA,OAAO,WAAW,CAAC,GAAG,EAAE,GAAG,KAAA,IAAA,IAAH,GAAG,KAAA,KAAA,CAAA,GAAH,GAAG,GAAI,SAAS,CAAC,CAAC;AAC3C,SAAA;KACF;AACF,CAAA;;ACTK,SAAU,eAAe,CAAC,UAAiB,EAAA;AAC/C,IAAA,OAAO,UAAU,CAAC,KAAK,CAAC,KAAK,IAAI,KAAK,YAAY,eAAe,CAAC,CAAC;AACrE,CAAC;MAGY,YAAY,CAAA;AADzB,IAAA,WAAA,GAAA;AAEY,QAAA,IAAA,CAAA,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC,CAAC;AAC5B,QAAA,IAAA,CAAA,MAAM,GAAG,IAAI,GAAG,EAAmC,CAAC;KA+D/D;AA7DC,IAAA,IAAI,EAAE,GAAA;QACJ,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;KACpC;AASM,IAAA,MAAM,CACX,KAAwB,EACxB,mBAAgD,EAChD,MAAe,EAAA;AAEf,QAAA,IAAI,CAAC,SAAS,CAAC,MAAM,IAAI,CAAC,KAAK;AAAE,YAAA,OAAO,SAAS,CAAC;QAClD,MAAM,aAAa,GAAG,KAAK,CAAC,OAAO,CAAC,mBAAmB,CAAC,CAAC;AAEzD,QAAA,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;YACxB,OAAO,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,mBAAmB,EAAE,MAAM,CAAC,CAAC,CAAC;AAC5E,SAAA;AAED,QAAA,IAAI,aAAa,EAAE;YACjB,MAAM,IAAI,GAAG,cAAc,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;YAC3C,UAAU,CAAC,IAAI,CAAC,CAAC;YACjB,MAAMA,KAAG,GAAGC,GAAK,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC;AACjC,YAAA,OAAOC,KAAoB,CAACF,KAAG,EAAE,GAAG,mBAAmB,CAAC,CAAC;AAC1D,SAAA;AAAM,aAAA;YACL,MAAM,IAAI,GAAG,cAAc,CAAC,KAAK,EAAE,mBAAmB,CAAC,CAAC;YACxD,UAAU,CAAC,IAAI,CAAC,CAAC;YACjB,OAAOC,GAAK,CAAC,IAAI,CAAC,EAAE,EAAE,IAAI,CAAC,CAAC;AAC7B,SAAA;KACF;AAED,IAAA,SAAS,CAAC,KAAY,EAAA;QACpB,IAAI,QAAQ,GAAoC,IAAI,CAAC;AACrD,QAAA,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,EAAE;AAChD,YAAA,IAAI,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;gBACtB,QAAQ,GAAG,KAAK,CAAC;gBACjB,MAAM;AACP,aAAA;AACF,SAAA;AACD,QAAA,IAAI,QAAQ;AAAE,YAAA,OAAO,QAAQ,CAAC;AAC9B,QAAA,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;QACzC,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAA6B,CAAC;KAC3D;IAED,MAAM,CAAI,IAAY,EAAE,OAAU,EAAA;QAChC,OAAO,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,OAAO,CAAC,CAAC;KACxC;IAED,MAAM,CAAI,IAAY,EAAE,KAAiB,EAAA;QACvC,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AAC9B,QAAA,OAAO,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;KAC3B;AAED,IAAA,MAAM,CAAC,IAAY,EAAA;QACjB,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AAC9B,QAAA,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;KACpB;;0GAhEU,YAAY,EAAA,IAAA,EAAA,EAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,UAAA,EAAA,CAAA,CAAA;AAAZ,YAAA,CAAA,KAAA,GAAA,EAAA,CAAA,qBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,SAAA,EAAA,QAAA,EAAA,EAAA,EAAA,IAAA,EAAA,YAAY,cADC,MAAM,EAAA,CAAA,CAAA;4FACnB,YAAY,EAAA,UAAA,EAAA,CAAA;kBADxB,UAAU;mBAAC,EAAE,UAAU,EAAE,MAAM,EAAE,CAAA;;;ACblC;AACM,SAAU,QAAQ,CAAI,MAAS,EAAA;IACnC,IAAI,OAAO,MAAM,KAAK,QAAQ;AAAE,QAAA,OAAO,MAAM,CAAC;AAC9C,IAAA,KAAK,MAAM,GAAG,IAAI,MAAM,EAAE;AACxB,QAAA,MAAM,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;AAC1B,QAAA,IAAI,CAAC,KAAK,IAAI,OAAO,KAAK,KAAK,QAAQ;YAAE,SAAS;QAClD,IAAI,KAAK,YAAY,IAAI,EAAE;YACzB,MAAM,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,OAAO,EAAS,CAAC;YACrC,SAAS;AACV,SAAA;QACD,QAAQ,CAAC,KAAK,CAAC,CAAA;AAChB,KAAA;AACD,IAAA,OAAO,MAAM,CAAC;AAChB,CAAC;AAED;AACM,SAAU,MAAM,CAAI,MAAS,EAAE,QAAkB,EAAE,OAAe,EAAE,EAAA;IACxE,IAAI,OAAO,MAAM,KAAK,QAAQ;AAAE,QAAA,OAAO,MAAM,CAAC;AAC9C,IAAA,KAAK,MAAM,GAAG,IAAI,MAAM,EAAE;AACxB,QAAA,MAAM,KAAK,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;AAC1B,QAAA,MAAM,OAAO,GAAG,CAAA,EAAG,IAAI,CAAI,CAAA,EAAA,GAAG,EAAE,CAAC;AACjC,QAAA,IAAI,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE;YAC9B,IAAI,OAAO,KAAK,KAAK,QAAQ;gBAAE,MAAM,IAAI,KAAK,CAAC,CAAA,UAAA,EAAa,OAAO,CAA0B,uBAAA,EAAA,KAAK,CAAE,CAAA,CAAC,CAAC;YACtG,MAAM,CAAC,GAAG,CAAC,GAAG,IAAI,IAAI,CAAC,KAAK,CAAQ,CAAC;YACrC,SAAS;AACV,SAAA;AACD,QAAA,IAAI,CAAC,KAAK,IAAI,OAAO,KAAK,KAAK,QAAQ;YAAE,SAAS;AAClD,QAAA,MAAM,CAAC,KAAK,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC;AAClC,KAAA;AACD,IAAA,OAAO,MAAM,CAAC;AAChB;;AChBA,SAAS,WAAW,CAAC,KAAsD,EAAA;IACzE,IAAI,OAAO,KAAK,KAAK,QAAQ;AAAE,QAAA,OAAO,KAAK,CAAC;IAC5C,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,QAAQ,CAAC,KAAK,CAAC;AAAE,QAAA,OAAO,KAAK,CAAC;AAC1D,IAAA,OAAO,IAAI,CAAC;AACd,CAAC;AAGD,SAAS,KAAK,CAAC,KAAc,EAAA;IAC3B,IAAI,OAAO,KAAK,KAAK,QAAQ;AAAE,QAAA,OAAO,KAAK,CAAC;IAC5C,IAAI,OAAO,KAAK,KAAK,QAAQ;AAAE,QAAA,OAAO,KAAK,CAAC,QAAQ,EAAE,CAAC;AACvD,IAAA,MAAM,IAAI,KAAK,CAAC,mDAAmD,CAAC,CAAC;AACvE,CAAC;AAEe,SAAA,OAAO,CAAC,GAAiB,EAAE,UAA4B,EAAA;;IACrE,MAAM,KAAK,GAA0B,CAAA,EAAA,GAAA,GAAG,CAAC,OAAO,CAAC,MAAI,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAA,EAAE,CAAC;IACxD,IAAI,UAAU,KAAK,KAAK;AAAE,QAAA,KAAK,CAAC,SAAS,GAAG,eAAe,EAAU,CAAC;IACtE,IAAI,UAAU,KAAK,QAAQ;AAAE,QAAA,KAAK,CAAC,UAAU,GAAG,eAAe,EAAU,CAAC;AAC1E,IAAA,GAAG,CAAC,KAAK,GAAG,KAAK,CAAC;AACpB,CAAC;MASqB,QAAQ,CAAA;AAA9B,IAAA,WAAA,GAAA;AACY,QAAA,IAAA,CAAA,MAAM,GAAG,MAAM,CAAC,YAAY,CAAC,CAAC;KAuIzC;AAjIW,IAAA,YAAY,CAAC,IAAkB,EAAA;AACvC,QAAA,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;AAAE,YAAA,OAAO,IAAI,CAAC;AAChC,QAAA,MAAM,KAAK,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;AAEzB,QAAA,MAAM,QAAQ,GAAG,CAAC,GAAG,IAAI,CAAC,QAAQ,EAAE,iBAAiB,EAAE,kBAAkB,CAAC,CAAC;AAC3E,QAAA,IAAI,CAAC,KAAK,IAAI,OAAO,KAAK,KAAK,QAAQ;AAAE,YAAA,OAAO,MAAM,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;QACxE,IAAI,IAAI,CAAC,KAAK;YAAE,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC;QAC7C,IAAI,IAAI,CAAC,OAAO;AAAE,YAAA,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC;AAC5D,QAAA,OAAO,MAAM,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;KAChC;IAES,UAAU,CAAC,GAAe,EAAE,UAA4B,EAAA;AAChE,QAAA,OAAO,QAAQ,CAAC,GAAG,CAAC,CAAC;KACtB;IAKO,MAAM,CAAkB,KAA2C,EAAE,OAAsB,EAAA;AACjG,QAAA,IAAI,CAAC,KAAK;AAAE,YAAA,OAAO,IAAI,CAAC;AACxB,QAAA,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC;YAAE,OAAO,KAAK,CAAC,GAAG,CAAC,IAAI,IAAI,IAAI,CAAC,MAAM,CAAI,IAAI,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAC1G,IAAI,CAAC,OAAO,CAAC,MAAM;AAAE,YAAA,OAAO,IAAI,CAAC,YAAY,CAAC,KAAK,CAAQ,CAAC;QAC5D,MAAM,IAAI,GAAiB,EAAE,CAAC;;QAE9B,KAAK,CAAC,OAAO,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,IAAI,CAAQ,CAAC,CAAC,CAAC;AAClE,QAAA,OAAO,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;KAC3B;IAED,OAAO,CAAC,GAAqB,EAAE,MAAe,EAAA;QAC5C,IAAI,OAAO,GAAG,KAAK,QAAQ;AAAE,YAAA,OAAO,cAAc,CAAC,CAAG,EAAA,IAAI,CAAC,IAAI,CAAI,CAAA,EAAA,GAAG,CAAE,CAAA,EAAE,MAAM,CAAC,CAAC;QAClF,OAAO,cAAc,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;KACvC;IASD,MAAM,CAAC,KAAsD,EAAE,MAAe,EAAA;;AAE5E,QAAA,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC;AAAE,YAAA,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,MAAM,CAAC,CAAC;QAElF,OAAO,QAAQ,CAAC,KAAK,CAAC;;cAElB,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,IAAI,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,EAAE,MAAM,CAAC;;AAEjE,cAAE,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,EAAE,KAAK,EAAE,MAAM,CAAC,CAAC;KACvD;IASO,SAAS,CAAC,KAAsD,EAAE,MAAe,EAAA;QACvF,MAAM,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;AACxC,QAAA,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC;YAAE,OAAO,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;AAC7D,QAAA,MAAM,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC;AACxD,QAAA,OAAO,aAAa,CAAC,GAAG,CAAC,CAAC;KAC3B;IASO,QAAQ,CAAC,KAAsD,EAAE,MAAe,EAAA;QACtF,MAAM,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;AACxC,QAAA,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC;AAAE,YAAA,OAAO,GAAG,CAAC,IAAI,CAAC,CAAC;AAC3C,QAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;AAC3C,QAAA,OAAO,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;KAC9B;IAOD,YAAY,CAAkB,KAAsD,EAAE,MAAe,EAAA;AACnG,QAAA,IAAI,SAAS,CAAC,MAAM,IAAI,CAAC,KAAK;AAAE,YAAA,OAAO,EAAE,CAAC,IAAI,CAAC,CAAC;AAChD,QAAA,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC,IAAI,CACvC,GAAG,CAAC,IAAI,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,EAAE,MAAM,EAAE,WAAW,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAC/D,CAAC;KACH;IAOK,QAAQ,CAAkB,KAAsD,EAAE,MAAe,EAAA;;AACrG,YAAA,IAAI,SAAS,CAAC,MAAM,IAAI,CAAC,KAAK;AAAE,gBAAA,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YAC7D,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,MAAM,CAAC,CAAA;AAC/C,YAAA,OAAO,IAAI,CAAC,MAAM,CAAI,IAAI,EAAE,EAAE,MAAM,EAAE,WAAW,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;SAC7D,CAAA,CAAA;AAAA,KAAA;IAED,GAAG,CAAc,KAAiB,EAAE,MAAe,EAAA;QACjD,MAAM,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;QAC1C,IAAI,IAAI,CAAC,KAAK,IAAI,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;YACjC,MAAM,GAAG,GAAG,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;YACnC,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;AACrC,YAAA,OAAO,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;AACtB,SAAA;AACD,QAAA,MAAM,OAAO,GAAG,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;AAC7D,QAAA,OAAO,IAAI,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;KAC3B;AAED,IAAA,MAAM,CAAc,GAAW,EAAE,KAAiB,EAAE,MAAe,EAAA;QACjE,MAAM,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;QAC7C,MAAM,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;AACtC,QAAA,OAAO,MAAM,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;KAC1B;IAED,MAAM,CAAC,GAAW,EAAE,MAAe,EAAA;QACjC,MAAM,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;AACrC,QAAA,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;KACpB;;AAGD,IAAA,SAAS,CAAC,MAAe,EAAA;AACvB,QAAA,MAAM,GAAG,GAAG,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC;AACzD,QAAA,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;KACpB;AACF;;ACjLD;;AAEG;;;;"}